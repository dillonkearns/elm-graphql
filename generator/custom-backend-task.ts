import * as fs from "fs";
import { GraphQLClient } from "graphql-request";
import { applyElmFormat } from "./src/formatted-write";
import { introspectionQuery } from "./src/introspection-query";
import * as path from "path";

import * as childProcess from "child_process";
import {
  removeGenerated,
  warnAndExitIfContainsNonGenerated,
  generateOrExitIntrospectionFileFromSchema,
} from "./src/cli/generated-code-handler";
import { npmPackageVersion, elmPackageVersion } from "./src/versions.js";

const targetComment = `-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql
`;

function prependBasePath(
  suffixPath: string,
  baseModule: string[],
  outputPath: string
): string {
  return path.join(outputPath, baseModule.join("/"), suffixPath);
}

export async function schemaFromFile({
  schemaFilePath,
  outputPath,
  baseModule,
  customDecodersModule,
}) {
  warnAndExitIfContainsNonGenerated({ baseModule, outputPath });
  return generateOrExitIntrospectionFileFromSchema(schemaFilePath);
}

export async function introspectSchemaFromFile({
  introspectionFilePath,
  outputPath,
  baseModule,
  customDecodersModule,
}: {
  introspectionFilePath: string;
  outputPath: string;
  baseModule: string[];
  customDecodersModule: string | null;
}) {
  warnAndExitIfContainsNonGenerated({ baseModule, outputPath });
  try {
    const introspectionFileJson = JSON.parse(
      fs.readFileSync(introspectionFilePath).toString()
    );

    // If it has a data.__schema structure, return the data property
    if (introspectionFileJson.data && introspectionFileJson.data.__schema) {
      return introspectionFileJson.data;
    }

    // If it has a __schema property directly, return the whole object
    if (introspectionFileJson.__schema) {
      return introspectionFileJson;
    }

    // Otherwise return the whole JSON, whatever it is
    return introspectionFileJson;
  } catch (e) {
    console.error("Failed to parse introspection file as JSON", e);
    process.exit(1);
  }
}

export async function introspectSchemaFromUrl({
  graphqlUrl,
  excludeDeprecated,
  outputPath,
  baseModule,
  headers,
  customDecodersModule,
}: {
  graphqlUrl: string;
  excludeDeprecated: boolean;
  outputPath: string;
  baseModule: string[];
  headers: {};
  customDecodersModule: string | null;
}) {
  warnAndExitIfContainsNonGenerated({ baseModule, outputPath });

  console.log("Fetching GraphQL schema...");
  return await new GraphQLClient(graphqlUrl, {
    mode: "cors",
    headers: headers,
  }).request(introspectionQuery, { includeDeprecated: !excludeDeprecated });
}

function makeEmptyDirectories(
  baseModule: string[],
  outputPath: string,
  directoryNames: string[]
): void {
  directoryNames.forEach((dir) => {
    fs.mkdirSync(prependBasePath(dir, baseModule, outputPath), {
      recursive: true,
    });
  });
}

export async function generatedFiles({
  outputPath,
  baseModule,
  customDecodersModule,
  generatedFile,
  skipElmFormat,
}) {
  removeGenerated(prependBasePath("/", baseModule, outputPath));
  makeEmptyDirectories(baseModule, outputPath, [
    "InputObject",
    "Object",
    "Interface",
    "Union",
    "Enum",
  ]);
  await Promise.all(writeGeneratedFiles(outputPath, generatedFile)).catch(
    (err) => {
      console.error("Error writing files", err);
    }
  );
  writeIntrospectionFile(baseModule, outputPath);
  if (!skipElmFormat) {
    applyElmFormat(prependBasePath("/", baseModule, outputPath));
  }
  if (customDecodersModule) {
    verifyCustomCodecsFileIsValid(outputPath, baseModule, customDecodersModule);
  }
  console.log("Success!");
}

function verifyCustomCodecsFileIsValid(
  outputPath: string,
  baseModule: string[],
  customDecodersModule: string
) {
  const verifyDecodersFile = path.join(
    outputPath,
    ...baseModule,
    "VerifyScalarCodecs.elm"
  );

  try {
    childProcess.execSync(`elm make ${verifyDecodersFile} --output=/dev/null`, {
      stdio: "pipe",
    });
  } catch (error) {
    console.error(error.message);

    console.error(`--------------------------------------------
        INVALID SCALAR DECODERS FILE
--------------------------------------------

Your custom scalar decoders module, \`${customDecodersModule}\`, is invalid.

This is because either:

1) This is the first time you've run this CLI with the \`--scalar-codecs\` option.
  In this case, get a valid file, you can start by copy-pasting \`${baseModule.join(
    "."
  )}.ScalarCodecs\`. Then change the module name to \`${customDecodersModule}\`
  and you have a valid starting point!
2) You added or renamed a Custom Scalar in your GraphQL schema.
   To handle the new Custom Scalar, you can copy the relevant entries from \`${customDecodersModule}\`.

Check the following:
    * You have a module called \`${customDecodersModule}\`
    * The module is somewhere in your elm path (check the \`source-directories\` in your \`elm.json\`)

    You must:
    * Have a type for every custom scalar
    * Expose each of these types
    * Expose a \`codecs\` value

    Above the dashes (----) there are some details that might help you debug the issue. Remember, you can always
    copy-paste the \`${baseModule.join(
      "."
    )}.ScalarCodecs\` module to get a valid file.

    After you've copy pasted the template file, or tried fixing the file,
    re-run this CLI command to make sure it is valid.
    `);
    process.exit(1);
  }
}

function writeGeneratedFiles(
  outputPath: string,
  generatedFile: {
    [s: string]: string;
  }
): Promise<void>[] {
  return Object.entries(generatedFile).map(([fileName, fileContents]) => {
    const filePath = path.join(outputPath, fileName);
    return fs.promises.writeFile(filePath, targetComment + fileContents);
  });
}

function writeIntrospectionFile(baseModule: string[], outputPath: string) {
  fs.writeFileSync(
    prependBasePath("elm-graphql-metadata.json", baseModule, outputPath),
    `{"targetElmPackageVersion": "${elmPackageVersion}", "generatedByNpmPackageVersion": "${npmPackageVersion}"}`
  );
}
