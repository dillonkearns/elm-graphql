// ../generator/custom-backend-task.ts
import * as fs2 from "fs";
import { GraphQLClient } from "graphql-request";

// ../generator/src/formatted-write.ts
import * as spawn from "cross-spawn";
var applyElmFormat = (fileOrFolderToFormat) => {
  try {
    const result = spawn.sync(`elm-format`, ["--elm-version", "0.19", "--yes", fileOrFolderToFormat]);
    if (result.status !== 0) {
      if (result?.error?.code === "ENOENT") {
        console.error("Unable to run elm-format. Please ensure that elm-format is available on your PATH and try again. Or re-run using --skip-elm-format.");
        process.exit(1);
      } else {
        console.error("Unable to run elm-format. Please ensure that elm-format is available on your PATH and try again. Or re-run using --skip-elm-format.\n\n", result.error);
        process.exit(1);
      }
    }
  } catch (error) {
    console.error("Unable to run elm-format. Please ensure that elm-format is available on your PATH and try again. Or re-run using --skip-elm-format.\n\n", error);
    process.exit(1);
  }
};

// ../generator/src/introspection-query.ts
var introspectionQuery = `query IntrospectionQuery($includeDeprecated: Boolean!) {
    __schema {
      queryType {
        name
      }
      mutationType {
        name
      }
      subscriptionType {
        name
      }
      types {
        ...FullType
      }
    }
  }

  fragment FullType on __Type {
    kind
    name
    description
    fields(includeDeprecated: $includeDeprecated) {
      name
      description
      args {
        ...InputValue
      }
      type {
        ...TypeRef
      }
      isDeprecated
      deprecationReason
    }
    inputFields {
      ...InputValue
    }
    interfaces {
      ...TypeRef
    }
    enumValues(includeDeprecated: $includeDeprecated) {
      name
      description
      isDeprecated
      deprecationReason
    }
    possibleTypes {
      ...TypeRef
    }
  }

  fragment InputValue on __InputValue {
    name
    description
    type { ...TypeRef }
    defaultValue
  }

  fragment TypeRef on __Type {
    kind
    name
    ofType {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                }
              }
            }
          }
        }
      }
    }
  }`;

// ../generator/custom-backend-task.ts
import * as path2 from "path";
import * as childProcess from "child_process";

// ../generator/src/cli/generated-code-handler.ts
import * as glob from "glob";
import * as fs from "fs";

// ../generator/src/cli/path-helpers.ts
import * as path from "path";
function prependBasePath(suffixPath, baseModule, outputPath) {
  return path.join(outputPath, baseModule.join("/"), suffixPath);
}

// ../generator/src/cli/generated-code-handler.ts
import { introspectionFromSchema, buildSchema } from "graphql";
function removeGenerated(path3) {
  glob.sync(path3 + "/**/*.elm").forEach(fs.unlinkSync);
}
function isGenerated(path3) {
  return fs.readFileSync(path3).indexOf("Do not manually edit this file, it was auto-generated by") >= 0;
}
function warnAndExitIfContainsNonGenerated({
  baseModule,
  outputPath
}) {
  const files = glob.sync(
    prependBasePath("/", baseModule, outputPath) + "/**/*.elm"
  );
  const nonGenerated = files.filter((file) => !isGenerated(file));
  if (nonGenerated.length > 0) {
    console.log(
      "@dillonkearns/elm-graphql found some files that it did not generate. Please move or delete the following files and run @dillonkearns/elm-graphql again.",
      nonGenerated
    );
    process.exit(1);
  }
}
function generateOrExitIntrospectionFileFromSchema(schemaFilePath) {
  console.log("schemaFilePath", schemaFilePath);
  if (fs.existsSync(schemaFilePath)) {
    const schemaData = fs.readFileSync(schemaFilePath, "utf-8");
    console.log("schemaData", schemaData);
    return JSON.parse(
      JSON.stringify(
        introspectionFromSchema(buildSchema(schemaData.toString()))
      )
    );
  } else {
    console.log("Schema file not found");
    process.exit(1);
  }
}

// ../generator/custom-backend-task.ts
var npmPackageVersion = "TODO";
var elmPackageVersion = "TODO";
var targetComment = `-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql
`;
function prependBasePath2(suffixPath, baseModule, outputPath) {
  return path2.join(outputPath, baseModule.join("/"), suffixPath);
}
async function schemaFromFile({
  schemaFilePath,
  outputPath,
  baseModule,
  customDecodersModule
}) {
  warnAndExitIfContainsNonGenerated({ baseModule, outputPath });
  return generateOrExitIntrospectionFileFromSchema(schemaFilePath);
}
async function introspectSchemaFromFile({
  introspectionFilePath,
  outputPath,
  baseModule,
  customDecodersModule
}) {
  warnAndExitIfContainsNonGenerated({ baseModule, outputPath });
  const introspectionFileJson = JSON.parse(
    fs2.readFileSync(introspectionFilePath).toString()
  );
  return introspectionFileJson.data || introspectionFileJson;
}
async function introspectSchemaFromUrl({
  graphqlUrl,
  excludeDeprecated,
  outputPath,
  baseModule,
  headers,
  customDecodersModule
}) {
  warnAndExitIfContainsNonGenerated({ baseModule, outputPath });
  console.log("Fetching GraphQL schema...");
  return await new GraphQLClient(graphqlUrl, {
    mode: "cors",
    headers
  }).request(introspectionQuery, { includeDeprecated: !excludeDeprecated });
}
function makeEmptyDirectories(baseModule, outputPath, directoryNames) {
  directoryNames.forEach((dir) => {
    fs2.mkdirSync(prependBasePath2(dir, baseModule, outputPath), {
      recursive: true
    });
  });
}
async function generatedFiles({
  outputPath,
  baseModule,
  customDecodersModule,
  generatedFile,
  skipElmFormat
}) {
  removeGenerated(prependBasePath2("/", baseModule, outputPath));
  makeEmptyDirectories(baseModule, outputPath, [
    "InputObject",
    "Object",
    "Interface",
    "Union",
    "Enum"
  ]);
  await Promise.all(writeGeneratedFiles(outputPath, generatedFile)).catch(
    (err) => {
      console.error("Error writing files", err);
    }
  );
  writeIntrospectionFile(baseModule, outputPath);
  if (!skipElmFormat) {
    applyElmFormat(prependBasePath2("/", baseModule, outputPath));
  }
  if (customDecodersModule) {
    verifyCustomCodecsFileIsValid(outputPath, baseModule, customDecodersModule);
  }
  console.log("Success!");
}
function verifyCustomCodecsFileIsValid(outputPath, baseModule, customDecodersModule) {
  const verifyDecodersFile = path2.join(
    outputPath,
    ...baseModule,
    "VerifyScalarCodecs.elm"
  );
  try {
    childProcess.execSync(`elm make ${verifyDecodersFile} --output=/dev/null`, {
      stdio: "pipe"
    });
  } catch (error) {
    console.error(error.message);
    console.error(`--------------------------------------------
        INVALID SCALAR DECODERS FILE
--------------------------------------------

Your custom scalar decoders module, \`${customDecodersModule}\`, is invalid.

This is because either:

1) This is the first time you've run this CLI with the \`--scalar-codecs\` option.
  In this case, get a valid file, you can start by copy-pasting \`${baseModule.join(
      "."
    )}.ScalarCodecs\`. Then change the module name to \`${customDecodersModule}\`
  and you have a valid starting point!
2) You added or renamed a Custom Scalar in your GraphQL schema.
   To handle the new Custom Scalar, you can copy the relevant entries from \`${customDecodersModule}\`.

Check the following:
    * You have a module called \`${customDecodersModule}\`
    * The module is somewhere in your elm path (check the \`source-directories\` in your \`elm.json\`)

    You must:
    * Have a type for every custom scalar
    * Expose each of these types
    * Expose a \`codecs\` value

    Above the dashes (----) there are some details that might help you debug the issue. Remember, you can always
    copy-paste the \`${baseModule.join(
      "."
    )}.ScalarCodecs\` module to get a valid file.

    After you've copy pasted the template file, or tried fixing the file,
    re-run this CLI command to make sure it is valid.
    `);
    process.exit(1);
  }
}
function writeGeneratedFiles(outputPath, generatedFile) {
  return Object.entries(generatedFile).map(([fileName, fileContents]) => {
    const filePath = path2.join(outputPath, fileName);
    return fs2.promises.writeFile(filePath, targetComment + fileContents);
  });
}
function writeIntrospectionFile(baseModule, outputPath) {
  fs2.writeFileSync(
    prependBasePath2("elm-graphql-metadata.json", baseModule, outputPath),
    `{"targetElmPackageVersion": "${elmPackageVersion}", "generatedByNpmPackageVersion": "${npmPackageVersion}"}`
  );
}
export {
  generatedFiles,
  introspectSchemaFromFile,
  introspectSchemaFromUrl,
  schemaFromFile
};
