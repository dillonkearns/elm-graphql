-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Hasura.Mutation exposing (DeleteOnlineUsersRequiredArguments, DeleteTodolistRequiredArguments, DeleteUsersRequiredArguments, InsertOnlineUsersRequiredArguments, InsertTodolistOptionalArguments, InsertTodolistRequiredArguments, InsertUsersOptionalArguments, InsertUsersRequiredArguments, UpdateOnlineUsersOptionalArguments, UpdateOnlineUsersRequiredArguments, UpdateTodolistOptionalArguments, UpdateTodolistRequiredArguments, UpdateUsersOptionalArguments, UpdateUsersRequiredArguments, delete_online_users, delete_todolist, delete_users, insert_online_users, insert_todolist, insert_users, update_online_users, update_todolist, update_users)

import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Hasura.InputObject
import Hasura.Interface
import Hasura.Object
import Hasura.Scalar
import Hasura.ScalarCodecs
import Hasura.Union
import Json.Decode as Decode exposing (Decoder)


type alias DeleteOnlineUsersRequiredArguments =
    { where_ : Hasura.InputObject.Online_users_bool_exp }


{-| delete data from the table: "online\_users"

  - where\_ - filter the rows which have to be deleted

-}
delete_online_users : DeleteOnlineUsersRequiredArguments -> SelectionSet decodesTo Hasura.Object.Online_users_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
delete_online_users requiredArgs object_ =
    Object.selectionForCompositeField "delete_online_users" [ Argument.required "where" requiredArgs.where_ Hasura.InputObject.encodeOnline_users_bool_exp ] object_ (identity >> Decode.nullable)


type alias DeleteTodolistRequiredArguments =
    { where_ : Hasura.InputObject.Todolist_bool_exp }


{-| delete data from the table: "todolist"

  - where\_ - filter the rows which have to be deleted

-}
delete_todolist : DeleteTodolistRequiredArguments -> SelectionSet decodesTo Hasura.Object.Todolist_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
delete_todolist requiredArgs object_ =
    Object.selectionForCompositeField "delete_todolist" [ Argument.required "where" requiredArgs.where_ Hasura.InputObject.encodeTodolist_bool_exp ] object_ (identity >> Decode.nullable)


type alias DeleteUsersRequiredArguments =
    { where_ : Hasura.InputObject.Users_bool_exp }


{-| delete data from the table: "users"

  - where\_ - filter the rows which have to be deleted

-}
delete_users : DeleteUsersRequiredArguments -> SelectionSet decodesTo Hasura.Object.Users_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
delete_users requiredArgs object_ =
    Object.selectionForCompositeField "delete_users" [ Argument.required "where" requiredArgs.where_ Hasura.InputObject.encodeUsers_bool_exp ] object_ (identity >> Decode.nullable)


type alias InsertOnlineUsersRequiredArguments =
    { objects : List Hasura.InputObject.Online_users_insert_input }


{-| insert data into the table: "online\_users"

  - objects - the rows to be inserted

-}
insert_online_users : InsertOnlineUsersRequiredArguments -> SelectionSet decodesTo Hasura.Object.Online_users_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
insert_online_users requiredArgs object_ =
    Object.selectionForCompositeField "insert_online_users" [ Argument.required "objects" requiredArgs.objects (Hasura.InputObject.encodeOnline_users_insert_input |> Encode.list) ] object_ (identity >> Decode.nullable)


type alias InsertTodolistOptionalArguments =
    { on_conflict : OptionalArgument Hasura.InputObject.Todolist_on_conflict }


type alias InsertTodolistRequiredArguments =
    { objects : List Hasura.InputObject.Todolist_insert_input }


{-| insert data into the table: "todolist"

  - objects - the rows to be inserted
  - on\_conflict - on conflict condition

-}
insert_todolist : (InsertTodolistOptionalArguments -> InsertTodolistOptionalArguments) -> InsertTodolistRequiredArguments -> SelectionSet decodesTo Hasura.Object.Todolist_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
insert_todolist fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { on_conflict = Absent }

        optionalArgs =
            [ Argument.optional "on_conflict" filledInOptionals.on_conflict Hasura.InputObject.encodeTodolist_on_conflict ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "insert_todolist" (optionalArgs ++ [ Argument.required "objects" requiredArgs.objects (Hasura.InputObject.encodeTodolist_insert_input |> Encode.list) ]) object_ (identity >> Decode.nullable)


type alias InsertUsersOptionalArguments =
    { on_conflict : OptionalArgument Hasura.InputObject.Users_on_conflict }


type alias InsertUsersRequiredArguments =
    { objects : List Hasura.InputObject.Users_insert_input }


{-| insert data into the table: "users"

  - objects - the rows to be inserted
  - on\_conflict - on conflict condition

-}
insert_users : (InsertUsersOptionalArguments -> InsertUsersOptionalArguments) -> InsertUsersRequiredArguments -> SelectionSet decodesTo Hasura.Object.Users_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
insert_users fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { on_conflict = Absent }

        optionalArgs =
            [ Argument.optional "on_conflict" filledInOptionals.on_conflict Hasura.InputObject.encodeUsers_on_conflict ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "insert_users" (optionalArgs ++ [ Argument.required "objects" requiredArgs.objects (Hasura.InputObject.encodeUsers_insert_input |> Encode.list) ]) object_ (identity >> Decode.nullable)


type alias UpdateOnlineUsersOptionalArguments =
    { inc_ : OptionalArgument Hasura.InputObject.Online_users_inc_input
    , set_ : OptionalArgument Hasura.InputObject.Online_users_set_input
    }


type alias UpdateOnlineUsersRequiredArguments =
    { where_ : Hasura.InputObject.Online_users_bool_exp }


{-| update data of the table: "online\_users"

  - inc\_ - increments the integer columns with given value of the filtered values
  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_online_users : (UpdateOnlineUsersOptionalArguments -> UpdateOnlineUsersOptionalArguments) -> UpdateOnlineUsersRequiredArguments -> SelectionSet decodesTo Hasura.Object.Online_users_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
update_online_users fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { inc_ = Absent, set_ = Absent }

        optionalArgs =
            [ Argument.optional "_inc" filledInOptionals.inc_ Hasura.InputObject.encodeOnline_users_inc_input, Argument.optional "_set" filledInOptionals.set_ Hasura.InputObject.encodeOnline_users_set_input ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "update_online_users" (optionalArgs ++ [ Argument.required "where" requiredArgs.where_ Hasura.InputObject.encodeOnline_users_bool_exp ]) object_ (identity >> Decode.nullable)


type alias UpdateTodolistOptionalArguments =
    { inc_ : OptionalArgument Hasura.InputObject.Todolist_inc_input
    , set_ : OptionalArgument Hasura.InputObject.Todolist_set_input
    }


type alias UpdateTodolistRequiredArguments =
    { where_ : Hasura.InputObject.Todolist_bool_exp }


{-| update data of the table: "todolist"

  - inc\_ - increments the integer columns with given value of the filtered values
  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_todolist : (UpdateTodolistOptionalArguments -> UpdateTodolistOptionalArguments) -> UpdateTodolistRequiredArguments -> SelectionSet decodesTo Hasura.Object.Todolist_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
update_todolist fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { inc_ = Absent, set_ = Absent }

        optionalArgs =
            [ Argument.optional "_inc" filledInOptionals.inc_ Hasura.InputObject.encodeTodolist_inc_input, Argument.optional "_set" filledInOptionals.set_ Hasura.InputObject.encodeTodolist_set_input ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "update_todolist" (optionalArgs ++ [ Argument.required "where" requiredArgs.where_ Hasura.InputObject.encodeTodolist_bool_exp ]) object_ (identity >> Decode.nullable)


type alias UpdateUsersOptionalArguments =
    { inc_ : OptionalArgument Hasura.InputObject.Users_inc_input
    , set_ : OptionalArgument Hasura.InputObject.Users_set_input
    }


type alias UpdateUsersRequiredArguments =
    { where_ : Hasura.InputObject.Users_bool_exp }


{-| update data of the table: "users"

  - inc\_ - increments the integer columns with given value of the filtered values
  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_users : (UpdateUsersOptionalArguments -> UpdateUsersOptionalArguments) -> UpdateUsersRequiredArguments -> SelectionSet decodesTo Hasura.Object.Users_mutation_response -> SelectionSet (Maybe decodesTo) RootMutation
update_users fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { inc_ = Absent, set_ = Absent }

        optionalArgs =
            [ Argument.optional "_inc" filledInOptionals.inc_ Hasura.InputObject.encodeUsers_inc_input, Argument.optional "_set" filledInOptionals.set_ Hasura.InputObject.encodeUsers_set_input ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "update_users" (optionalArgs ++ [ Argument.required "where" requiredArgs.where_ Hasura.InputObject.encodeUsers_bool_exp ]) object_ (identity >> Decode.nullable)
