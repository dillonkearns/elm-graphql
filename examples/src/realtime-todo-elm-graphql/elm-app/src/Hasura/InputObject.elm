-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Hasura.InputObject exposing (Boolean_comparison_exp, Boolean_comparison_expOptionalFields, Integer_comparison_exp, Integer_comparison_expOptionalFields, Online_users_aggregate_order_by, Online_users_aggregate_order_byOptionalFields, Online_users_arr_rel_insert_input, Online_users_arr_rel_insert_inputRequiredFields, Online_users_avg_order_by, Online_users_avg_order_byOptionalFields, Online_users_bool_exp(..), Online_users_bool_expOptionalFields, Online_users_bool_expRaw, Online_users_inc_input, Online_users_inc_inputOptionalFields, Online_users_insert_input, Online_users_insert_inputOptionalFields, Online_users_max_order_by, Online_users_max_order_byOptionalFields, Online_users_min_order_by, Online_users_min_order_byOptionalFields, Online_users_obj_rel_insert_input, Online_users_obj_rel_insert_inputRequiredFields, Online_users_order_by, Online_users_order_byOptionalFields, Online_users_set_input, Online_users_set_inputOptionalFields, Online_users_stddev_order_by, Online_users_stddev_order_byOptionalFields, Online_users_stddev_pop_order_by, Online_users_stddev_pop_order_byOptionalFields, Online_users_stddev_samp_order_by, Online_users_stddev_samp_order_byOptionalFields, Online_users_sum_order_by, Online_users_sum_order_byOptionalFields, Online_users_var_pop_order_by, Online_users_var_pop_order_byOptionalFields, Online_users_var_samp_order_by, Online_users_var_samp_order_byOptionalFields, Online_users_variance_order_by, Online_users_variance_order_byOptionalFields, Text_comparison_exp, Text_comparison_expOptionalFields, Timestamptz_comparison_exp, Timestamptz_comparison_expOptionalFields, Todolist_aggregate_order_by, Todolist_aggregate_order_byOptionalFields, Todolist_arr_rel_insert_input(..), Todolist_arr_rel_insert_inputOptionalFields, Todolist_arr_rel_insert_inputRaw, Todolist_arr_rel_insert_inputRequiredFields, Todolist_avg_order_by, Todolist_avg_order_byOptionalFields, Todolist_bool_exp(..), Todolist_bool_expOptionalFields, Todolist_bool_expRaw, Todolist_inc_input, Todolist_inc_inputOptionalFields, Todolist_insert_input, Todolist_insert_inputOptionalFields, Todolist_max_order_by, Todolist_max_order_byOptionalFields, Todolist_min_order_by, Todolist_min_order_byOptionalFields, Todolist_obj_rel_insert_input(..), Todolist_obj_rel_insert_inputOptionalFields, Todolist_obj_rel_insert_inputRaw, Todolist_obj_rel_insert_inputRequiredFields, Todolist_on_conflict, Todolist_on_conflictRequiredFields, Todolist_order_by, Todolist_order_byOptionalFields, Todolist_set_input, Todolist_set_inputOptionalFields, Todolist_stddev_order_by, Todolist_stddev_order_byOptionalFields, Todolist_stddev_pop_order_by, Todolist_stddev_pop_order_byOptionalFields, Todolist_stddev_samp_order_by, Todolist_stddev_samp_order_byOptionalFields, Todolist_sum_order_by, Todolist_sum_order_byOptionalFields, Todolist_var_pop_order_by, Todolist_var_pop_order_byOptionalFields, Todolist_var_samp_order_by, Todolist_var_samp_order_byOptionalFields, Todolist_variance_order_by, Todolist_variance_order_byOptionalFields, Users_aggregate_order_by, Users_aggregate_order_byOptionalFields, Users_arr_rel_insert_input, Users_arr_rel_insert_inputOptionalFields, Users_arr_rel_insert_inputRequiredFields, Users_avg_order_by, Users_avg_order_byOptionalFields, Users_bool_exp(..), Users_bool_expOptionalFields, Users_bool_expRaw, Users_inc_input, Users_inc_inputOptionalFields, Users_insert_input, Users_insert_inputOptionalFields, Users_max_order_by, Users_max_order_byOptionalFields, Users_min_order_by, Users_min_order_byOptionalFields, Users_obj_rel_insert_input, Users_obj_rel_insert_inputOptionalFields, Users_obj_rel_insert_inputRequiredFields, Users_on_conflict, Users_on_conflictRequiredFields, Users_order_by, Users_order_byOptionalFields, Users_set_input, Users_set_inputOptionalFields, Users_stddev_order_by, Users_stddev_order_byOptionalFields, Users_stddev_pop_order_by, Users_stddev_pop_order_byOptionalFields, Users_stddev_samp_order_by, Users_stddev_samp_order_byOptionalFields, Users_sum_order_by, Users_sum_order_byOptionalFields, Users_var_pop_order_by, Users_var_pop_order_byOptionalFields, Users_var_samp_order_by, Users_var_samp_order_byOptionalFields, Users_variance_order_by, Users_variance_order_byOptionalFields, buildBoolean_comparison_exp, buildInteger_comparison_exp, buildOnline_users_aggregate_order_by, buildOnline_users_arr_rel_insert_input, buildOnline_users_avg_order_by, buildOnline_users_bool_exp, buildOnline_users_inc_input, buildOnline_users_insert_input, buildOnline_users_max_order_by, buildOnline_users_min_order_by, buildOnline_users_obj_rel_insert_input, buildOnline_users_order_by, buildOnline_users_set_input, buildOnline_users_stddev_order_by, buildOnline_users_stddev_pop_order_by, buildOnline_users_stddev_samp_order_by, buildOnline_users_sum_order_by, buildOnline_users_var_pop_order_by, buildOnline_users_var_samp_order_by, buildOnline_users_variance_order_by, buildText_comparison_exp, buildTimestamptz_comparison_exp, buildTodolist_aggregate_order_by, buildTodolist_arr_rel_insert_input, buildTodolist_avg_order_by, buildTodolist_bool_exp, buildTodolist_inc_input, buildTodolist_insert_input, buildTodolist_max_order_by, buildTodolist_min_order_by, buildTodolist_obj_rel_insert_input, buildTodolist_on_conflict, buildTodolist_order_by, buildTodolist_set_input, buildTodolist_stddev_order_by, buildTodolist_stddev_pop_order_by, buildTodolist_stddev_samp_order_by, buildTodolist_sum_order_by, buildTodolist_var_pop_order_by, buildTodolist_var_samp_order_by, buildTodolist_variance_order_by, buildUsers_aggregate_order_by, buildUsers_arr_rel_insert_input, buildUsers_avg_order_by, buildUsers_bool_exp, buildUsers_inc_input, buildUsers_insert_input, buildUsers_max_order_by, buildUsers_min_order_by, buildUsers_obj_rel_insert_input, buildUsers_on_conflict, buildUsers_order_by, buildUsers_set_input, buildUsers_stddev_order_by, buildUsers_stddev_pop_order_by, buildUsers_stddev_samp_order_by, buildUsers_sum_order_by, buildUsers_var_pop_order_by, buildUsers_var_samp_order_by, buildUsers_variance_order_by, encodeBoolean_comparison_exp, encodeInteger_comparison_exp, encodeOnline_users_aggregate_order_by, encodeOnline_users_arr_rel_insert_input, encodeOnline_users_avg_order_by, encodeOnline_users_bool_exp, encodeOnline_users_inc_input, encodeOnline_users_insert_input, encodeOnline_users_max_order_by, encodeOnline_users_min_order_by, encodeOnline_users_obj_rel_insert_input, encodeOnline_users_order_by, encodeOnline_users_set_input, encodeOnline_users_stddev_order_by, encodeOnline_users_stddev_pop_order_by, encodeOnline_users_stddev_samp_order_by, encodeOnline_users_sum_order_by, encodeOnline_users_var_pop_order_by, encodeOnline_users_var_samp_order_by, encodeOnline_users_variance_order_by, encodeText_comparison_exp, encodeTimestamptz_comparison_exp, encodeTodolist_aggregate_order_by, encodeTodolist_arr_rel_insert_input, encodeTodolist_avg_order_by, encodeTodolist_bool_exp, encodeTodolist_inc_input, encodeTodolist_insert_input, encodeTodolist_max_order_by, encodeTodolist_min_order_by, encodeTodolist_obj_rel_insert_input, encodeTodolist_on_conflict, encodeTodolist_order_by, encodeTodolist_set_input, encodeTodolist_stddev_order_by, encodeTodolist_stddev_pop_order_by, encodeTodolist_stddev_samp_order_by, encodeTodolist_sum_order_by, encodeTodolist_var_pop_order_by, encodeTodolist_var_samp_order_by, encodeTodolist_variance_order_by, encodeUsers_aggregate_order_by, encodeUsers_arr_rel_insert_input, encodeUsers_avg_order_by, encodeUsers_bool_exp, encodeUsers_inc_input, encodeUsers_insert_input, encodeUsers_max_order_by, encodeUsers_min_order_by, encodeUsers_obj_rel_insert_input, encodeUsers_on_conflict, encodeUsers_order_by, encodeUsers_set_input, encodeUsers_stddev_order_by, encodeUsers_stddev_pop_order_by, encodeUsers_stddev_samp_order_by, encodeUsers_sum_order_by, encodeUsers_var_pop_order_by, encodeUsers_var_samp_order_by, encodeUsers_variance_order_by)

import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Hasura.Enum.Order_by
import Hasura.Enum.Todolist_constraint
import Hasura.Enum.Todolist_update_column
import Hasura.Enum.Users_constraint
import Hasura.Enum.Users_update_column
import Hasura.Interface
import Hasura.Object
import Hasura.Scalar
import Hasura.ScalarCodecs
import Hasura.Union
import Json.Decode as Decode


buildBoolean_comparison_exp : (Boolean_comparison_expOptionalFields -> Boolean_comparison_expOptionalFields) -> Boolean_comparison_exp
buildBoolean_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Boolean_comparison_expOptionalFields =
    { eq_ : OptionalArgument Bool
    , gt_ : OptionalArgument Bool
    , gte_ : OptionalArgument Bool
    , in_ : OptionalArgument (List (Maybe Bool))
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Bool
    , lte_ : OptionalArgument Bool
    , neq_ : OptionalArgument Bool
    , nin_ : OptionalArgument (List (Maybe Bool))
    }


{-| Type for the Boolean\_comparison\_exp input object.
-}
type alias Boolean_comparison_exp =
    { eq_ : OptionalArgument Bool
    , gt_ : OptionalArgument Bool
    , gte_ : OptionalArgument Bool
    , in_ : OptionalArgument (List (Maybe Bool))
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Bool
    , lte_ : OptionalArgument Bool
    , neq_ : OptionalArgument Bool
    , nin_ : OptionalArgument (List (Maybe Bool))
    }


{-| Encode a Boolean\_comparison\_exp into a value that can be used as an argument.
-}
encodeBoolean_comparison_exp : Boolean_comparison_exp -> Value
encodeBoolean_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.bool |> Encode.optional input.eq_ ), ( "_gt", Encode.bool |> Encode.optional input.gt_ ), ( "_gte", Encode.bool |> Encode.optional input.gte_ ), ( "_in", (Encode.bool |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", Encode.bool |> Encode.optional input.lt_ ), ( "_lte", Encode.bool |> Encode.optional input.lte_ ), ( "_neq", Encode.bool |> Encode.optional input.neq_ ), ( "_nin", (Encode.bool |> Encode.maybe |> Encode.list) |> Encode.optional input.nin_ ) ]


buildInteger_comparison_exp : (Integer_comparison_expOptionalFields -> Integer_comparison_expOptionalFields) -> Integer_comparison_exp
buildInteger_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Integer_comparison_expOptionalFields =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List (Maybe Int))
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List (Maybe Int))
    }


{-| Type for the Integer\_comparison\_exp input object.
-}
type alias Integer_comparison_exp =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List (Maybe Int))
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List (Maybe Int))
    }


{-| Encode a Integer\_comparison\_exp into a value that can be used as an argument.
-}
encodeInteger_comparison_exp : Integer_comparison_exp -> Value
encodeInteger_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.int |> Encode.optional input.eq_ ), ( "_gt", Encode.int |> Encode.optional input.gt_ ), ( "_gte", Encode.int |> Encode.optional input.gte_ ), ( "_in", (Encode.int |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", Encode.int |> Encode.optional input.lt_ ), ( "_lte", Encode.int |> Encode.optional input.lte_ ), ( "_neq", Encode.int |> Encode.optional input.neq_ ), ( "_nin", (Encode.int |> Encode.maybe |> Encode.list) |> Encode.optional input.nin_ ) ]


buildOnline_users_aggregate_order_by : (Online_users_aggregate_order_byOptionalFields -> Online_users_aggregate_order_byOptionalFields) -> Online_users_aggregate_order_by
buildOnline_users_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { avg = Absent, count = Absent, max = Absent, min = Absent, stddev = Absent, stddev_pop = Absent, stddev_samp = Absent, sum = Absent, var_pop = Absent, var_samp = Absent, variance = Absent }
    in
    { avg = optionals.avg, count = optionals.count, max = optionals.max, min = optionals.min, stddev = optionals.stddev, stddev_pop = optionals.stddev_pop, stddev_samp = optionals.stddev_samp, sum = optionals.sum, var_pop = optionals.var_pop, var_samp = optionals.var_samp, variance = optionals.variance }


type alias Online_users_aggregate_order_byOptionalFields =
    { avg : OptionalArgument Online_users_avg_order_by
    , count : OptionalArgument Hasura.Enum.Order_by.Order_by
    , max : OptionalArgument Online_users_max_order_by
    , min : OptionalArgument Online_users_min_order_by
    , stddev : OptionalArgument Online_users_stddev_order_by
    , stddev_pop : OptionalArgument Online_users_stddev_pop_order_by
    , stddev_samp : OptionalArgument Online_users_stddev_samp_order_by
    , sum : OptionalArgument Online_users_sum_order_by
    , var_pop : OptionalArgument Online_users_var_pop_order_by
    , var_samp : OptionalArgument Online_users_var_samp_order_by
    , variance : OptionalArgument Online_users_variance_order_by
    }


{-| Type for the Online\_users\_aggregate\_order\_by input object.
-}
type alias Online_users_aggregate_order_by =
    { avg : OptionalArgument Online_users_avg_order_by
    , count : OptionalArgument Hasura.Enum.Order_by.Order_by
    , max : OptionalArgument Online_users_max_order_by
    , min : OptionalArgument Online_users_min_order_by
    , stddev : OptionalArgument Online_users_stddev_order_by
    , stddev_pop : OptionalArgument Online_users_stddev_pop_order_by
    , stddev_samp : OptionalArgument Online_users_stddev_samp_order_by
    , sum : OptionalArgument Online_users_sum_order_by
    , var_pop : OptionalArgument Online_users_var_pop_order_by
    , var_samp : OptionalArgument Online_users_var_samp_order_by
    , variance : OptionalArgument Online_users_variance_order_by
    }


{-| Encode a Online\_users\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeOnline_users_aggregate_order_by : Online_users_aggregate_order_by -> Value
encodeOnline_users_aggregate_order_by input =
    Encode.maybeObject
        [ ( "avg", encodeOnline_users_avg_order_by |> Encode.optional input.avg ), ( "count", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeOnline_users_max_order_by |> Encode.optional input.max ), ( "min", encodeOnline_users_min_order_by |> Encode.optional input.min ), ( "stddev", encodeOnline_users_stddev_order_by |> Encode.optional input.stddev ), ( "stddev_pop", encodeOnline_users_stddev_pop_order_by |> Encode.optional input.stddev_pop ), ( "stddev_samp", encodeOnline_users_stddev_samp_order_by |> Encode.optional input.stddev_samp ), ( "sum", encodeOnline_users_sum_order_by |> Encode.optional input.sum ), ( "var_pop", encodeOnline_users_var_pop_order_by |> Encode.optional input.var_pop ), ( "var_samp", encodeOnline_users_var_samp_order_by |> Encode.optional input.var_samp ), ( "variance", encodeOnline_users_variance_order_by |> Encode.optional input.variance ) ]


buildOnline_users_arr_rel_insert_input : Online_users_arr_rel_insert_inputRequiredFields -> Online_users_arr_rel_insert_input
buildOnline_users_arr_rel_insert_input required =
    { data = required.data }


type alias Online_users_arr_rel_insert_inputRequiredFields =
    { data : List Online_users_insert_input }


{-| Type for the Online\_users\_arr\_rel\_insert\_input input object.
-}
type alias Online_users_arr_rel_insert_input =
    { data : List Online_users_insert_input }


{-| Encode a Online\_users\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeOnline_users_arr_rel_insert_input : Online_users_arr_rel_insert_input -> Value
encodeOnline_users_arr_rel_insert_input input =
    Encode.maybeObject
        [ ( "data", (encodeOnline_users_insert_input |> Encode.list) input.data |> Just ) ]


buildOnline_users_avg_order_by : (Online_users_avg_order_byOptionalFields -> Online_users_avg_order_byOptionalFields) -> Online_users_avg_order_by
buildOnline_users_avg_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Online_users_avg_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Online\_users\_avg\_order\_by input object.
-}
type alias Online_users_avg_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Online\_users\_avg\_order\_by into a value that can be used as an argument.
-}
encodeOnline_users_avg_order_by : Online_users_avg_order_by -> Value
encodeOnline_users_avg_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildOnline_users_bool_exp : (Online_users_bool_expOptionalFields -> Online_users_bool_expOptionalFields) -> Online_users_bool_exp
buildOnline_users_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, id = Absent, last_seen = Absent, username = Absent }
    in
    Online_users_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, id = optionals.id, last_seen = optionals.last_seen, username = optionals.username }


type alias Online_users_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Online_users_bool_exp))
    , not_ : OptionalArgument Online_users_bool_exp
    , or_ : OptionalArgument (List (Maybe Online_users_bool_exp))
    , id : OptionalArgument Integer_comparison_exp
    , last_seen : OptionalArgument Timestamptz_comparison_exp
    , username : OptionalArgument Text_comparison_exp
    }


{-| Type alias for the `Online_users_bool_exp` attributes. Note that this type
needs to use the `Online_users_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Online_users_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Online_users_bool_exp))
    , not_ : OptionalArgument Online_users_bool_exp
    , or_ : OptionalArgument (List (Maybe Online_users_bool_exp))
    , id : OptionalArgument Integer_comparison_exp
    , last_seen : OptionalArgument Timestamptz_comparison_exp
    , username : OptionalArgument Text_comparison_exp
    }


{-| Type for the Online\_users\_bool\_exp input object.
-}
type Online_users_bool_exp
    = Online_users_bool_exp Online_users_bool_expRaw


{-| Encode a Online\_users\_bool\_exp into a value that can be used as an argument.
-}
encodeOnline_users_bool_exp : Online_users_bool_exp -> Value
encodeOnline_users_bool_exp (Online_users_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeOnline_users_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeOnline_users_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeOnline_users_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "id", encodeInteger_comparison_exp |> Encode.optional input.id ), ( "last_seen", encodeTimestamptz_comparison_exp |> Encode.optional input.last_seen ), ( "username", encodeText_comparison_exp |> Encode.optional input.username ) ]


buildOnline_users_inc_input : (Online_users_inc_inputOptionalFields -> Online_users_inc_inputOptionalFields) -> Online_users_inc_input
buildOnline_users_inc_input fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Online_users_inc_inputOptionalFields =
    { id : OptionalArgument Int }


{-| Type for the Online\_users\_inc\_input input object.
-}
type alias Online_users_inc_input =
    { id : OptionalArgument Int }


{-| Encode a Online\_users\_inc\_input into a value that can be used as an argument.
-}
encodeOnline_users_inc_input : Online_users_inc_input -> Value
encodeOnline_users_inc_input input =
    Encode.maybeObject
        [ ( "id", Encode.int |> Encode.optional input.id ) ]


buildOnline_users_insert_input : (Online_users_insert_inputOptionalFields -> Online_users_insert_inputOptionalFields) -> Online_users_insert_input
buildOnline_users_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, last_seen = Absent, username = Absent }
    in
    { id = optionals.id, last_seen = optionals.last_seen, username = optionals.username }


type alias Online_users_insert_inputOptionalFields =
    { id : OptionalArgument Int
    , last_seen : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , username : OptionalArgument String
    }


{-| Type for the Online\_users\_insert\_input input object.
-}
type alias Online_users_insert_input =
    { id : OptionalArgument Int
    , last_seen : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , username : OptionalArgument String
    }


{-| Encode a Online\_users\_insert\_input into a value that can be used as an argument.
-}
encodeOnline_users_insert_input : Online_users_insert_input -> Value
encodeOnline_users_insert_input input =
    Encode.maybeObject
        [ ( "id", Encode.int |> Encode.optional input.id ), ( "last_seen", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.last_seen ), ( "username", Encode.string |> Encode.optional input.username ) ]


buildOnline_users_max_order_by : (Online_users_max_order_byOptionalFields -> Online_users_max_order_byOptionalFields) -> Online_users_max_order_by
buildOnline_users_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, last_seen = Absent, username = Absent }
    in
    { id = optionals.id, last_seen = optionals.last_seen, username = optionals.username }


type alias Online_users_max_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , last_seen : OptionalArgument Hasura.Enum.Order_by.Order_by
    , username : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Online\_users\_max\_order\_by input object.
-}
type alias Online_users_max_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , last_seen : OptionalArgument Hasura.Enum.Order_by.Order_by
    , username : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Online\_users\_max\_order\_by into a value that can be used as an argument.
-}
encodeOnline_users_max_order_by : Online_users_max_order_by -> Value
encodeOnline_users_max_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ), ( "last_seen", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.last_seen ), ( "username", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.username ) ]


buildOnline_users_min_order_by : (Online_users_min_order_byOptionalFields -> Online_users_min_order_byOptionalFields) -> Online_users_min_order_by
buildOnline_users_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, last_seen = Absent, username = Absent }
    in
    { id = optionals.id, last_seen = optionals.last_seen, username = optionals.username }


type alias Online_users_min_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , last_seen : OptionalArgument Hasura.Enum.Order_by.Order_by
    , username : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Online\_users\_min\_order\_by input object.
-}
type alias Online_users_min_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , last_seen : OptionalArgument Hasura.Enum.Order_by.Order_by
    , username : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Online\_users\_min\_order\_by into a value that can be used as an argument.
-}
encodeOnline_users_min_order_by : Online_users_min_order_by -> Value
encodeOnline_users_min_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ), ( "last_seen", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.last_seen ), ( "username", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.username ) ]


buildOnline_users_obj_rel_insert_input : Online_users_obj_rel_insert_inputRequiredFields -> Online_users_obj_rel_insert_input
buildOnline_users_obj_rel_insert_input required =
    { data = required.data }


type alias Online_users_obj_rel_insert_inputRequiredFields =
    { data : Online_users_insert_input }


{-| Type for the Online\_users\_obj\_rel\_insert\_input input object.
-}
type alias Online_users_obj_rel_insert_input =
    { data : Online_users_insert_input }


{-| Encode a Online\_users\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeOnline_users_obj_rel_insert_input : Online_users_obj_rel_insert_input -> Value
encodeOnline_users_obj_rel_insert_input input =
    Encode.maybeObject
        [ ( "data", encodeOnline_users_insert_input input.data |> Just ) ]


buildOnline_users_order_by : (Online_users_order_byOptionalFields -> Online_users_order_byOptionalFields) -> Online_users_order_by
buildOnline_users_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, last_seen = Absent, username = Absent }
    in
    { id = optionals.id, last_seen = optionals.last_seen, username = optionals.username }


type alias Online_users_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , last_seen : OptionalArgument Hasura.Enum.Order_by.Order_by
    , username : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Online\_users\_order\_by input object.
-}
type alias Online_users_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , last_seen : OptionalArgument Hasura.Enum.Order_by.Order_by
    , username : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Online\_users\_order\_by into a value that can be used as an argument.
-}
encodeOnline_users_order_by : Online_users_order_by -> Value
encodeOnline_users_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ), ( "last_seen", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.last_seen ), ( "username", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.username ) ]


buildOnline_users_set_input : (Online_users_set_inputOptionalFields -> Online_users_set_inputOptionalFields) -> Online_users_set_input
buildOnline_users_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, last_seen = Absent, username = Absent }
    in
    { id = optionals.id, last_seen = optionals.last_seen, username = optionals.username }


type alias Online_users_set_inputOptionalFields =
    { id : OptionalArgument Int
    , last_seen : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , username : OptionalArgument String
    }


{-| Type for the Online\_users\_set\_input input object.
-}
type alias Online_users_set_input =
    { id : OptionalArgument Int
    , last_seen : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , username : OptionalArgument String
    }


{-| Encode a Online\_users\_set\_input into a value that can be used as an argument.
-}
encodeOnline_users_set_input : Online_users_set_input -> Value
encodeOnline_users_set_input input =
    Encode.maybeObject
        [ ( "id", Encode.int |> Encode.optional input.id ), ( "last_seen", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.last_seen ), ( "username", Encode.string |> Encode.optional input.username ) ]


buildOnline_users_stddev_order_by : (Online_users_stddev_order_byOptionalFields -> Online_users_stddev_order_byOptionalFields) -> Online_users_stddev_order_by
buildOnline_users_stddev_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Online_users_stddev_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Online\_users\_stddev\_order\_by input object.
-}
type alias Online_users_stddev_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Online\_users\_stddev\_order\_by into a value that can be used as an argument.
-}
encodeOnline_users_stddev_order_by : Online_users_stddev_order_by -> Value
encodeOnline_users_stddev_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildOnline_users_stddev_pop_order_by : (Online_users_stddev_pop_order_byOptionalFields -> Online_users_stddev_pop_order_byOptionalFields) -> Online_users_stddev_pop_order_by
buildOnline_users_stddev_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Online_users_stddev_pop_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Online\_users\_stddev\_pop\_order\_by input object.
-}
type alias Online_users_stddev_pop_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Online\_users\_stddev\_pop\_order\_by into a value that can be used as an argument.
-}
encodeOnline_users_stddev_pop_order_by : Online_users_stddev_pop_order_by -> Value
encodeOnline_users_stddev_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildOnline_users_stddev_samp_order_by : (Online_users_stddev_samp_order_byOptionalFields -> Online_users_stddev_samp_order_byOptionalFields) -> Online_users_stddev_samp_order_by
buildOnline_users_stddev_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Online_users_stddev_samp_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Online\_users\_stddev\_samp\_order\_by input object.
-}
type alias Online_users_stddev_samp_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Online\_users\_stddev\_samp\_order\_by into a value that can be used as an argument.
-}
encodeOnline_users_stddev_samp_order_by : Online_users_stddev_samp_order_by -> Value
encodeOnline_users_stddev_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildOnline_users_sum_order_by : (Online_users_sum_order_byOptionalFields -> Online_users_sum_order_byOptionalFields) -> Online_users_sum_order_by
buildOnline_users_sum_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Online_users_sum_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Online\_users\_sum\_order\_by input object.
-}
type alias Online_users_sum_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Online\_users\_sum\_order\_by into a value that can be used as an argument.
-}
encodeOnline_users_sum_order_by : Online_users_sum_order_by -> Value
encodeOnline_users_sum_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildOnline_users_var_pop_order_by : (Online_users_var_pop_order_byOptionalFields -> Online_users_var_pop_order_byOptionalFields) -> Online_users_var_pop_order_by
buildOnline_users_var_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Online_users_var_pop_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Online\_users\_var\_pop\_order\_by input object.
-}
type alias Online_users_var_pop_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Online\_users\_var\_pop\_order\_by into a value that can be used as an argument.
-}
encodeOnline_users_var_pop_order_by : Online_users_var_pop_order_by -> Value
encodeOnline_users_var_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildOnline_users_var_samp_order_by : (Online_users_var_samp_order_byOptionalFields -> Online_users_var_samp_order_byOptionalFields) -> Online_users_var_samp_order_by
buildOnline_users_var_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Online_users_var_samp_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Online\_users\_var\_samp\_order\_by input object.
-}
type alias Online_users_var_samp_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Online\_users\_var\_samp\_order\_by into a value that can be used as an argument.
-}
encodeOnline_users_var_samp_order_by : Online_users_var_samp_order_by -> Value
encodeOnline_users_var_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildOnline_users_variance_order_by : (Online_users_variance_order_byOptionalFields -> Online_users_variance_order_byOptionalFields) -> Online_users_variance_order_by
buildOnline_users_variance_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Online_users_variance_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Online\_users\_variance\_order\_by input object.
-}
type alias Online_users_variance_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Online\_users\_variance\_order\_by into a value that can be used as an argument.
-}
encodeOnline_users_variance_order_by : Online_users_variance_order_by -> Value
encodeOnline_users_variance_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildText_comparison_exp : (Text_comparison_expOptionalFields -> Text_comparison_expOptionalFields) -> Text_comparison_exp
buildText_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, ilike_ = Absent, in_ = Absent, is_null_ = Absent, like_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nilike_ = Absent, nin_ = Absent, nlike_ = Absent, nsimilar_ = Absent, similar_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, ilike_ = optionals.ilike_, in_ = optionals.in_, is_null_ = optionals.is_null_, like_ = optionals.like_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nilike_ = optionals.nilike_, nin_ = optionals.nin_, nlike_ = optionals.nlike_, nsimilar_ = optionals.nsimilar_, similar_ = optionals.similar_ }


type alias Text_comparison_expOptionalFields =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List (Maybe String))
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Type for the Text\_comparison\_exp input object.
-}
type alias Text_comparison_exp =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List (Maybe String))
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Encode a Text\_comparison\_exp into a value that can be used as an argument.
-}
encodeText_comparison_exp : Text_comparison_exp -> Value
encodeText_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.string |> Encode.optional input.eq_ ), ( "_gt", Encode.string |> Encode.optional input.gt_ ), ( "_gte", Encode.string |> Encode.optional input.gte_ ), ( "_ilike", Encode.string |> Encode.optional input.ilike_ ), ( "_in", (Encode.string |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_like", Encode.string |> Encode.optional input.like_ ), ( "_lt", Encode.string |> Encode.optional input.lt_ ), ( "_lte", Encode.string |> Encode.optional input.lte_ ), ( "_neq", Encode.string |> Encode.optional input.neq_ ), ( "_nilike", Encode.string |> Encode.optional input.nilike_ ), ( "_nin", (Encode.string |> Encode.maybe |> Encode.list) |> Encode.optional input.nin_ ), ( "_nlike", Encode.string |> Encode.optional input.nlike_ ), ( "_nsimilar", Encode.string |> Encode.optional input.nsimilar_ ), ( "_similar", Encode.string |> Encode.optional input.similar_ ) ]


buildTimestamptz_comparison_exp : (Timestamptz_comparison_expOptionalFields -> Timestamptz_comparison_expOptionalFields) -> Timestamptz_comparison_exp
buildTimestamptz_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Timestamptz_comparison_expOptionalFields =
    { eq_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , gt_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , gte_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , in_ : OptionalArgument (List (Maybe Hasura.ScalarCodecs.Timestamptz))
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , lte_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , neq_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , nin_ : OptionalArgument (List (Maybe Hasura.ScalarCodecs.Timestamptz))
    }


{-| Type for the Timestamptz\_comparison\_exp input object.
-}
type alias Timestamptz_comparison_exp =
    { eq_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , gt_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , gte_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , in_ : OptionalArgument (List (Maybe Hasura.ScalarCodecs.Timestamptz))
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , lte_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , neq_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , nin_ : OptionalArgument (List (Maybe Hasura.ScalarCodecs.Timestamptz))
    }


{-| Encode a Timestamptz\_comparison\_exp into a value that can be used as an argument.
-}
encodeTimestamptz_comparison_exp : Timestamptz_comparison_exp -> Value
encodeTimestamptz_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.eq_ ), ( "_gt", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.gt_ ), ( "_gte", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.gte_ ), ( "_in", ((Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.lt_ ), ( "_lte", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.lte_ ), ( "_neq", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.neq_ ), ( "_nin", ((Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.maybe |> Encode.list) |> Encode.optional input.nin_ ) ]


buildTodolist_aggregate_order_by : (Todolist_aggregate_order_byOptionalFields -> Todolist_aggregate_order_byOptionalFields) -> Todolist_aggregate_order_by
buildTodolist_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { avg = Absent, count = Absent, max = Absent, min = Absent, stddev = Absent, stddev_pop = Absent, stddev_samp = Absent, sum = Absent, var_pop = Absent, var_samp = Absent, variance = Absent }
    in
    { avg = optionals.avg, count = optionals.count, max = optionals.max, min = optionals.min, stddev = optionals.stddev, stddev_pop = optionals.stddev_pop, stddev_samp = optionals.stddev_samp, sum = optionals.sum, var_pop = optionals.var_pop, var_samp = optionals.var_samp, variance = optionals.variance }


type alias Todolist_aggregate_order_byOptionalFields =
    { avg : OptionalArgument Todolist_avg_order_by
    , count : OptionalArgument Hasura.Enum.Order_by.Order_by
    , max : OptionalArgument Todolist_max_order_by
    , min : OptionalArgument Todolist_min_order_by
    , stddev : OptionalArgument Todolist_stddev_order_by
    , stddev_pop : OptionalArgument Todolist_stddev_pop_order_by
    , stddev_samp : OptionalArgument Todolist_stddev_samp_order_by
    , sum : OptionalArgument Todolist_sum_order_by
    , var_pop : OptionalArgument Todolist_var_pop_order_by
    , var_samp : OptionalArgument Todolist_var_samp_order_by
    , variance : OptionalArgument Todolist_variance_order_by
    }


{-| Type for the Todolist\_aggregate\_order\_by input object.
-}
type alias Todolist_aggregate_order_by =
    { avg : OptionalArgument Todolist_avg_order_by
    , count : OptionalArgument Hasura.Enum.Order_by.Order_by
    , max : OptionalArgument Todolist_max_order_by
    , min : OptionalArgument Todolist_min_order_by
    , stddev : OptionalArgument Todolist_stddev_order_by
    , stddev_pop : OptionalArgument Todolist_stddev_pop_order_by
    , stddev_samp : OptionalArgument Todolist_stddev_samp_order_by
    , sum : OptionalArgument Todolist_sum_order_by
    , var_pop : OptionalArgument Todolist_var_pop_order_by
    , var_samp : OptionalArgument Todolist_var_samp_order_by
    , variance : OptionalArgument Todolist_variance_order_by
    }


{-| Encode a Todolist\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeTodolist_aggregate_order_by : Todolist_aggregate_order_by -> Value
encodeTodolist_aggregate_order_by input =
    Encode.maybeObject
        [ ( "avg", encodeTodolist_avg_order_by |> Encode.optional input.avg ), ( "count", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeTodolist_max_order_by |> Encode.optional input.max ), ( "min", encodeTodolist_min_order_by |> Encode.optional input.min ), ( "stddev", encodeTodolist_stddev_order_by |> Encode.optional input.stddev ), ( "stddev_pop", encodeTodolist_stddev_pop_order_by |> Encode.optional input.stddev_pop ), ( "stddev_samp", encodeTodolist_stddev_samp_order_by |> Encode.optional input.stddev_samp ), ( "sum", encodeTodolist_sum_order_by |> Encode.optional input.sum ), ( "var_pop", encodeTodolist_var_pop_order_by |> Encode.optional input.var_pop ), ( "var_samp", encodeTodolist_var_samp_order_by |> Encode.optional input.var_samp ), ( "variance", encodeTodolist_variance_order_by |> Encode.optional input.variance ) ]


buildTodolist_arr_rel_insert_input : Todolist_arr_rel_insert_inputRequiredFields -> (Todolist_arr_rel_insert_inputOptionalFields -> Todolist_arr_rel_insert_inputOptionalFields) -> Todolist_arr_rel_insert_input
buildTodolist_arr_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Todolist_arr_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Todolist_arr_rel_insert_inputRequiredFields =
    { data : List Todolist_insert_input }


type alias Todolist_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Todolist_on_conflict }


{-| Type alias for the `Todolist_arr_rel_insert_input` attributes. Note that this type
needs to use the `Todolist_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Todolist_arr_rel_insert_inputRaw =
    { data : List Todolist_insert_input
    , on_conflict : OptionalArgument Todolist_on_conflict
    }


{-| Type for the Todolist\_arr\_rel\_insert\_input input object.
-}
type Todolist_arr_rel_insert_input
    = Todolist_arr_rel_insert_input Todolist_arr_rel_insert_inputRaw


{-| Encode a Todolist\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeTodolist_arr_rel_insert_input : Todolist_arr_rel_insert_input -> Value
encodeTodolist_arr_rel_insert_input (Todolist_arr_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", (encodeTodolist_insert_input |> Encode.list) input.data |> Just ), ( "on_conflict", encodeTodolist_on_conflict |> Encode.optional input.on_conflict ) ]


buildTodolist_avg_order_by : (Todolist_avg_order_byOptionalFields -> Todolist_avg_order_byOptionalFields) -> Todolist_avg_order_by
buildTodolist_avg_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, user_id = Absent }
    in
    { id = optionals.id, user_id = optionals.user_id }


type alias Todolist_avg_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Todolist\_avg\_order\_by input object.
-}
type alias Todolist_avg_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Todolist\_avg\_order\_by into a value that can be used as an argument.
-}
encodeTodolist_avg_order_by : Todolist_avg_order_by -> Value
encodeTodolist_avg_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildTodolist_bool_exp : (Todolist_bool_expOptionalFields -> Todolist_bool_expOptionalFields) -> Todolist_bool_exp
buildTodolist_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, created_at = Absent, id = Absent, is_completed = Absent, is_public = Absent, task = Absent, user = Absent, user_id = Absent }
    in
    Todolist_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, created_at = optionals.created_at, id = optionals.id, is_completed = optionals.is_completed, is_public = optionals.is_public, task = optionals.task, user = optionals.user, user_id = optionals.user_id }


type alias Todolist_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Todolist_bool_exp))
    , not_ : OptionalArgument Todolist_bool_exp
    , or_ : OptionalArgument (List (Maybe Todolist_bool_exp))
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Integer_comparison_exp
    , is_completed : OptionalArgument Boolean_comparison_exp
    , is_public : OptionalArgument Boolean_comparison_exp
    , task : OptionalArgument Text_comparison_exp
    , user : OptionalArgument Users_bool_exp
    , user_id : OptionalArgument Integer_comparison_exp
    }


{-| Type alias for the `Todolist_bool_exp` attributes. Note that this type
needs to use the `Todolist_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Todolist_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Todolist_bool_exp))
    , not_ : OptionalArgument Todolist_bool_exp
    , or_ : OptionalArgument (List (Maybe Todolist_bool_exp))
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Integer_comparison_exp
    , is_completed : OptionalArgument Boolean_comparison_exp
    , is_public : OptionalArgument Boolean_comparison_exp
    , task : OptionalArgument Text_comparison_exp
    , user : OptionalArgument Users_bool_exp
    , user_id : OptionalArgument Integer_comparison_exp
    }


{-| Type for the Todolist\_bool\_exp input object.
-}
type Todolist_bool_exp
    = Todolist_bool_exp Todolist_bool_expRaw


{-| Encode a Todolist\_bool\_exp into a value that can be used as an argument.
-}
encodeTodolist_bool_exp : Todolist_bool_exp -> Value
encodeTodolist_bool_exp (Todolist_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeTodolist_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeTodolist_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeTodolist_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "created_at", encodeTimestamptz_comparison_exp |> Encode.optional input.created_at ), ( "id", encodeInteger_comparison_exp |> Encode.optional input.id ), ( "is_completed", encodeBoolean_comparison_exp |> Encode.optional input.is_completed ), ( "is_public", encodeBoolean_comparison_exp |> Encode.optional input.is_public ), ( "task", encodeText_comparison_exp |> Encode.optional input.task ), ( "user", encodeUsers_bool_exp |> Encode.optional input.user ), ( "user_id", encodeInteger_comparison_exp |> Encode.optional input.user_id ) ]


buildTodolist_inc_input : (Todolist_inc_inputOptionalFields -> Todolist_inc_inputOptionalFields) -> Todolist_inc_input
buildTodolist_inc_input fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, user_id = Absent }
    in
    { id = optionals.id, user_id = optionals.user_id }


type alias Todolist_inc_inputOptionalFields =
    { id : OptionalArgument Int
    , user_id : OptionalArgument Int
    }


{-| Type for the Todolist\_inc\_input input object.
-}
type alias Todolist_inc_input =
    { id : OptionalArgument Int
    , user_id : OptionalArgument Int
    }


{-| Encode a Todolist\_inc\_input into a value that can be used as an argument.
-}
encodeTodolist_inc_input : Todolist_inc_input -> Value
encodeTodolist_inc_input input =
    Encode.maybeObject
        [ ( "id", Encode.int |> Encode.optional input.id ), ( "user_id", Encode.int |> Encode.optional input.user_id ) ]


buildTodolist_insert_input : (Todolist_insert_inputOptionalFields -> Todolist_insert_inputOptionalFields) -> Todolist_insert_input
buildTodolist_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { created_at = Absent, id = Absent, is_completed = Absent, is_public = Absent, task = Absent, user = Absent, user_id = Absent }
    in
    { created_at = optionals.created_at, id = optionals.id, is_completed = optionals.is_completed, is_public = optionals.is_public, task = optionals.task, user = optionals.user, user_id = optionals.user_id }


type alias Todolist_insert_inputOptionalFields =
    { created_at : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , id : OptionalArgument Int
    , is_completed : OptionalArgument Bool
    , is_public : OptionalArgument Bool
    , task : OptionalArgument String
    , user : OptionalArgument Users_obj_rel_insert_input
    , user_id : OptionalArgument Int
    }


{-| Type for the Todolist\_insert\_input input object.
-}
type alias Todolist_insert_input =
    { created_at : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , id : OptionalArgument Int
    , is_completed : OptionalArgument Bool
    , is_public : OptionalArgument Bool
    , task : OptionalArgument String
    , user : OptionalArgument Users_obj_rel_insert_input
    , user_id : OptionalArgument Int
    }


{-| Encode a Todolist\_insert\_input into a value that can be used as an argument.
-}
encodeTodolist_insert_input : Todolist_insert_input -> Value
encodeTodolist_insert_input input =
    Encode.maybeObject
        [ ( "created_at", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.created_at ), ( "id", Encode.int |> Encode.optional input.id ), ( "is_completed", Encode.bool |> Encode.optional input.is_completed ), ( "is_public", Encode.bool |> Encode.optional input.is_public ), ( "task", Encode.string |> Encode.optional input.task ), ( "user", encodeUsers_obj_rel_insert_input |> Encode.optional input.user ), ( "user_id", Encode.int |> Encode.optional input.user_id ) ]


buildTodolist_max_order_by : (Todolist_max_order_byOptionalFields -> Todolist_max_order_byOptionalFields) -> Todolist_max_order_by
buildTodolist_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { created_at = Absent, id = Absent, task = Absent, user_id = Absent }
    in
    { created_at = optionals.created_at, id = optionals.id, task = optionals.task, user_id = optionals.user_id }


type alias Todolist_max_order_byOptionalFields =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , task : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Todolist\_max\_order\_by input object.
-}
type alias Todolist_max_order_by =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , task : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Todolist\_max\_order\_by into a value that can be used as an argument.
-}
encodeTodolist_max_order_by : Todolist_max_order_by -> Value
encodeTodolist_max_order_by input =
    Encode.maybeObject
        [ ( "created_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.created_at ), ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ), ( "task", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.task ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildTodolist_min_order_by : (Todolist_min_order_byOptionalFields -> Todolist_min_order_byOptionalFields) -> Todolist_min_order_by
buildTodolist_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { created_at = Absent, id = Absent, task = Absent, user_id = Absent }
    in
    { created_at = optionals.created_at, id = optionals.id, task = optionals.task, user_id = optionals.user_id }


type alias Todolist_min_order_byOptionalFields =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , task : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Todolist\_min\_order\_by input object.
-}
type alias Todolist_min_order_by =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , task : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Todolist\_min\_order\_by into a value that can be used as an argument.
-}
encodeTodolist_min_order_by : Todolist_min_order_by -> Value
encodeTodolist_min_order_by input =
    Encode.maybeObject
        [ ( "created_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.created_at ), ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ), ( "task", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.task ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildTodolist_obj_rel_insert_input : Todolist_obj_rel_insert_inputRequiredFields -> (Todolist_obj_rel_insert_inputOptionalFields -> Todolist_obj_rel_insert_inputOptionalFields) -> Todolist_obj_rel_insert_input
buildTodolist_obj_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Todolist_obj_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Todolist_obj_rel_insert_inputRequiredFields =
    { data : Todolist_insert_input }


type alias Todolist_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Todolist_on_conflict }


{-| Type alias for the `Todolist_obj_rel_insert_input` attributes. Note that this type
needs to use the `Todolist_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Todolist_obj_rel_insert_inputRaw =
    { data : Todolist_insert_input
    , on_conflict : OptionalArgument Todolist_on_conflict
    }


{-| Type for the Todolist\_obj\_rel\_insert\_input input object.
-}
type Todolist_obj_rel_insert_input
    = Todolist_obj_rel_insert_input Todolist_obj_rel_insert_inputRaw


{-| Encode a Todolist\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeTodolist_obj_rel_insert_input : Todolist_obj_rel_insert_input -> Value
encodeTodolist_obj_rel_insert_input (Todolist_obj_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", encodeTodolist_insert_input input.data |> Just ), ( "on_conflict", encodeTodolist_on_conflict |> Encode.optional input.on_conflict ) ]


buildTodolist_on_conflict : Todolist_on_conflictRequiredFields -> Todolist_on_conflict
buildTodolist_on_conflict required =
    { constraint = required.constraint, update_columns = required.update_columns }


type alias Todolist_on_conflictRequiredFields =
    { constraint : Hasura.Enum.Todolist_constraint.Todolist_constraint
    , update_columns : List Hasura.Enum.Todolist_update_column.Todolist_update_column
    }


{-| Type for the Todolist\_on\_conflict input object.
-}
type alias Todolist_on_conflict =
    { constraint : Hasura.Enum.Todolist_constraint.Todolist_constraint
    , update_columns : List Hasura.Enum.Todolist_update_column.Todolist_update_column
    }


{-| Encode a Todolist\_on\_conflict into a value that can be used as an argument.
-}
encodeTodolist_on_conflict : Todolist_on_conflict -> Value
encodeTodolist_on_conflict input =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Hasura.Enum.Todolist_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Hasura.Enum.Todolist_update_column.toString |> Encode.list) input.update_columns |> Just ) ]


buildTodolist_order_by : (Todolist_order_byOptionalFields -> Todolist_order_byOptionalFields) -> Todolist_order_by
buildTodolist_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { created_at = Absent, id = Absent, is_completed = Absent, is_public = Absent, task = Absent, user = Absent, user_id = Absent }
    in
    { created_at = optionals.created_at, id = optionals.id, is_completed = optionals.is_completed, is_public = optionals.is_public, task = optionals.task, user = optionals.user, user_id = optionals.user_id }


type alias Todolist_order_byOptionalFields =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , is_completed : OptionalArgument Hasura.Enum.Order_by.Order_by
    , is_public : OptionalArgument Hasura.Enum.Order_by.Order_by
    , task : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user : OptionalArgument Users_order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Todolist\_order\_by input object.
-}
type alias Todolist_order_by =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , is_completed : OptionalArgument Hasura.Enum.Order_by.Order_by
    , is_public : OptionalArgument Hasura.Enum.Order_by.Order_by
    , task : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user : OptionalArgument Users_order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Todolist\_order\_by into a value that can be used as an argument.
-}
encodeTodolist_order_by : Todolist_order_by -> Value
encodeTodolist_order_by input =
    Encode.maybeObject
        [ ( "created_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.created_at ), ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ), ( "is_completed", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.is_completed ), ( "is_public", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.is_public ), ( "task", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.task ), ( "user", encodeUsers_order_by |> Encode.optional input.user ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildTodolist_set_input : (Todolist_set_inputOptionalFields -> Todolist_set_inputOptionalFields) -> Todolist_set_input
buildTodolist_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { created_at = Absent, id = Absent, is_completed = Absent, is_public = Absent, task = Absent, user_id = Absent }
    in
    { created_at = optionals.created_at, id = optionals.id, is_completed = optionals.is_completed, is_public = optionals.is_public, task = optionals.task, user_id = optionals.user_id }


type alias Todolist_set_inputOptionalFields =
    { created_at : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , id : OptionalArgument Int
    , is_completed : OptionalArgument Bool
    , is_public : OptionalArgument Bool
    , task : OptionalArgument String
    , user_id : OptionalArgument Int
    }


{-| Type for the Todolist\_set\_input input object.
-}
type alias Todolist_set_input =
    { created_at : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , id : OptionalArgument Int
    , is_completed : OptionalArgument Bool
    , is_public : OptionalArgument Bool
    , task : OptionalArgument String
    , user_id : OptionalArgument Int
    }


{-| Encode a Todolist\_set\_input into a value that can be used as an argument.
-}
encodeTodolist_set_input : Todolist_set_input -> Value
encodeTodolist_set_input input =
    Encode.maybeObject
        [ ( "created_at", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.created_at ), ( "id", Encode.int |> Encode.optional input.id ), ( "is_completed", Encode.bool |> Encode.optional input.is_completed ), ( "is_public", Encode.bool |> Encode.optional input.is_public ), ( "task", Encode.string |> Encode.optional input.task ), ( "user_id", Encode.int |> Encode.optional input.user_id ) ]


buildTodolist_stddev_order_by : (Todolist_stddev_order_byOptionalFields -> Todolist_stddev_order_byOptionalFields) -> Todolist_stddev_order_by
buildTodolist_stddev_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, user_id = Absent }
    in
    { id = optionals.id, user_id = optionals.user_id }


type alias Todolist_stddev_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Todolist\_stddev\_order\_by input object.
-}
type alias Todolist_stddev_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Todolist\_stddev\_order\_by into a value that can be used as an argument.
-}
encodeTodolist_stddev_order_by : Todolist_stddev_order_by -> Value
encodeTodolist_stddev_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildTodolist_stddev_pop_order_by : (Todolist_stddev_pop_order_byOptionalFields -> Todolist_stddev_pop_order_byOptionalFields) -> Todolist_stddev_pop_order_by
buildTodolist_stddev_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, user_id = Absent }
    in
    { id = optionals.id, user_id = optionals.user_id }


type alias Todolist_stddev_pop_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Todolist\_stddev\_pop\_order\_by input object.
-}
type alias Todolist_stddev_pop_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Todolist\_stddev\_pop\_order\_by into a value that can be used as an argument.
-}
encodeTodolist_stddev_pop_order_by : Todolist_stddev_pop_order_by -> Value
encodeTodolist_stddev_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildTodolist_stddev_samp_order_by : (Todolist_stddev_samp_order_byOptionalFields -> Todolist_stddev_samp_order_byOptionalFields) -> Todolist_stddev_samp_order_by
buildTodolist_stddev_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, user_id = Absent }
    in
    { id = optionals.id, user_id = optionals.user_id }


type alias Todolist_stddev_samp_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Todolist\_stddev\_samp\_order\_by input object.
-}
type alias Todolist_stddev_samp_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Todolist\_stddev\_samp\_order\_by into a value that can be used as an argument.
-}
encodeTodolist_stddev_samp_order_by : Todolist_stddev_samp_order_by -> Value
encodeTodolist_stddev_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildTodolist_sum_order_by : (Todolist_sum_order_byOptionalFields -> Todolist_sum_order_byOptionalFields) -> Todolist_sum_order_by
buildTodolist_sum_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, user_id = Absent }
    in
    { id = optionals.id, user_id = optionals.user_id }


type alias Todolist_sum_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Todolist\_sum\_order\_by input object.
-}
type alias Todolist_sum_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Todolist\_sum\_order\_by into a value that can be used as an argument.
-}
encodeTodolist_sum_order_by : Todolist_sum_order_by -> Value
encodeTodolist_sum_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildTodolist_var_pop_order_by : (Todolist_var_pop_order_byOptionalFields -> Todolist_var_pop_order_byOptionalFields) -> Todolist_var_pop_order_by
buildTodolist_var_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, user_id = Absent }
    in
    { id = optionals.id, user_id = optionals.user_id }


type alias Todolist_var_pop_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Todolist\_var\_pop\_order\_by input object.
-}
type alias Todolist_var_pop_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Todolist\_var\_pop\_order\_by into a value that can be used as an argument.
-}
encodeTodolist_var_pop_order_by : Todolist_var_pop_order_by -> Value
encodeTodolist_var_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildTodolist_var_samp_order_by : (Todolist_var_samp_order_byOptionalFields -> Todolist_var_samp_order_byOptionalFields) -> Todolist_var_samp_order_by
buildTodolist_var_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, user_id = Absent }
    in
    { id = optionals.id, user_id = optionals.user_id }


type alias Todolist_var_samp_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Todolist\_var\_samp\_order\_by input object.
-}
type alias Todolist_var_samp_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Todolist\_var\_samp\_order\_by into a value that can be used as an argument.
-}
encodeTodolist_var_samp_order_by : Todolist_var_samp_order_by -> Value
encodeTodolist_var_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildTodolist_variance_order_by : (Todolist_variance_order_byOptionalFields -> Todolist_variance_order_byOptionalFields) -> Todolist_variance_order_by
buildTodolist_variance_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, user_id = Absent }
    in
    { id = optionals.id, user_id = optionals.user_id }


type alias Todolist_variance_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Todolist\_variance\_order\_by input object.
-}
type alias Todolist_variance_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Todolist\_variance\_order\_by into a value that can be used as an argument.
-}
encodeTodolist_variance_order_by : Todolist_variance_order_by -> Value
encodeTodolist_variance_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildUsers_aggregate_order_by : (Users_aggregate_order_byOptionalFields -> Users_aggregate_order_byOptionalFields) -> Users_aggregate_order_by
buildUsers_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { avg = Absent, count = Absent, max = Absent, min = Absent, stddev = Absent, stddev_pop = Absent, stddev_samp = Absent, sum = Absent, var_pop = Absent, var_samp = Absent, variance = Absent }
    in
    { avg = optionals.avg, count = optionals.count, max = optionals.max, min = optionals.min, stddev = optionals.stddev, stddev_pop = optionals.stddev_pop, stddev_samp = optionals.stddev_samp, sum = optionals.sum, var_pop = optionals.var_pop, var_samp = optionals.var_samp, variance = optionals.variance }


type alias Users_aggregate_order_byOptionalFields =
    { avg : OptionalArgument Users_avg_order_by
    , count : OptionalArgument Hasura.Enum.Order_by.Order_by
    , max : OptionalArgument Users_max_order_by
    , min : OptionalArgument Users_min_order_by
    , stddev : OptionalArgument Users_stddev_order_by
    , stddev_pop : OptionalArgument Users_stddev_pop_order_by
    , stddev_samp : OptionalArgument Users_stddev_samp_order_by
    , sum : OptionalArgument Users_sum_order_by
    , var_pop : OptionalArgument Users_var_pop_order_by
    , var_samp : OptionalArgument Users_var_samp_order_by
    , variance : OptionalArgument Users_variance_order_by
    }


{-| Type for the Users\_aggregate\_order\_by input object.
-}
type alias Users_aggregate_order_by =
    { avg : OptionalArgument Users_avg_order_by
    , count : OptionalArgument Hasura.Enum.Order_by.Order_by
    , max : OptionalArgument Users_max_order_by
    , min : OptionalArgument Users_min_order_by
    , stddev : OptionalArgument Users_stddev_order_by
    , stddev_pop : OptionalArgument Users_stddev_pop_order_by
    , stddev_samp : OptionalArgument Users_stddev_samp_order_by
    , sum : OptionalArgument Users_sum_order_by
    , var_pop : OptionalArgument Users_var_pop_order_by
    , var_samp : OptionalArgument Users_var_samp_order_by
    , variance : OptionalArgument Users_variance_order_by
    }


{-| Encode a Users\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeUsers_aggregate_order_by : Users_aggregate_order_by -> Value
encodeUsers_aggregate_order_by input =
    Encode.maybeObject
        [ ( "avg", encodeUsers_avg_order_by |> Encode.optional input.avg ), ( "count", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeUsers_max_order_by |> Encode.optional input.max ), ( "min", encodeUsers_min_order_by |> Encode.optional input.min ), ( "stddev", encodeUsers_stddev_order_by |> Encode.optional input.stddev ), ( "stddev_pop", encodeUsers_stddev_pop_order_by |> Encode.optional input.stddev_pop ), ( "stddev_samp", encodeUsers_stddev_samp_order_by |> Encode.optional input.stddev_samp ), ( "sum", encodeUsers_sum_order_by |> Encode.optional input.sum ), ( "var_pop", encodeUsers_var_pop_order_by |> Encode.optional input.var_pop ), ( "var_samp", encodeUsers_var_samp_order_by |> Encode.optional input.var_samp ), ( "variance", encodeUsers_variance_order_by |> Encode.optional input.variance ) ]


buildUsers_arr_rel_insert_input : Users_arr_rel_insert_inputRequiredFields -> (Users_arr_rel_insert_inputOptionalFields -> Users_arr_rel_insert_inputOptionalFields) -> Users_arr_rel_insert_input
buildUsers_arr_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    { data = required.data, on_conflict = optionals.on_conflict }


type alias Users_arr_rel_insert_inputRequiredFields =
    { data : List Users_insert_input }


type alias Users_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Users_on_conflict }


{-| Type for the Users\_arr\_rel\_insert\_input input object.
-}
type alias Users_arr_rel_insert_input =
    { data : List Users_insert_input
    , on_conflict : OptionalArgument Users_on_conflict
    }


{-| Encode a Users\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeUsers_arr_rel_insert_input : Users_arr_rel_insert_input -> Value
encodeUsers_arr_rel_insert_input input =
    Encode.maybeObject
        [ ( "data", (encodeUsers_insert_input |> Encode.list) input.data |> Just ), ( "on_conflict", encodeUsers_on_conflict |> Encode.optional input.on_conflict ) ]


buildUsers_avg_order_by : (Users_avg_order_byOptionalFields -> Users_avg_order_byOptionalFields) -> Users_avg_order_by
buildUsers_avg_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Users_avg_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Users\_avg\_order\_by input object.
-}
type alias Users_avg_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Users\_avg\_order\_by into a value that can be used as an argument.
-}
encodeUsers_avg_order_by : Users_avg_order_by -> Value
encodeUsers_avg_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildUsers_bool_exp : (Users_bool_expOptionalFields -> Users_bool_expOptionalFields) -> Users_bool_exp
buildUsers_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, created_at = Absent, id = Absent, last_seen = Absent, password = Absent, token = Absent, username = Absent }
    in
    Users_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, created_at = optionals.created_at, id = optionals.id, last_seen = optionals.last_seen, password = optionals.password, token = optionals.token, username = optionals.username }


type alias Users_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Users_bool_exp))
    , not_ : OptionalArgument Users_bool_exp
    , or_ : OptionalArgument (List (Maybe Users_bool_exp))
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Integer_comparison_exp
    , last_seen : OptionalArgument Timestamptz_comparison_exp
    , password : OptionalArgument Text_comparison_exp
    , token : OptionalArgument Text_comparison_exp
    , username : OptionalArgument Text_comparison_exp
    }


{-| Type alias for the `Users_bool_exp` attributes. Note that this type
needs to use the `Users_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Users_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Users_bool_exp))
    , not_ : OptionalArgument Users_bool_exp
    , or_ : OptionalArgument (List (Maybe Users_bool_exp))
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Integer_comparison_exp
    , last_seen : OptionalArgument Timestamptz_comparison_exp
    , password : OptionalArgument Text_comparison_exp
    , token : OptionalArgument Text_comparison_exp
    , username : OptionalArgument Text_comparison_exp
    }


{-| Type for the Users\_bool\_exp input object.
-}
type Users_bool_exp
    = Users_bool_exp Users_bool_expRaw


{-| Encode a Users\_bool\_exp into a value that can be used as an argument.
-}
encodeUsers_bool_exp : Users_bool_exp -> Value
encodeUsers_bool_exp (Users_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeUsers_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeUsers_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeUsers_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "created_at", encodeTimestamptz_comparison_exp |> Encode.optional input.created_at ), ( "id", encodeInteger_comparison_exp |> Encode.optional input.id ), ( "last_seen", encodeTimestamptz_comparison_exp |> Encode.optional input.last_seen ), ( "password", encodeText_comparison_exp |> Encode.optional input.password ), ( "token", encodeText_comparison_exp |> Encode.optional input.token ), ( "username", encodeText_comparison_exp |> Encode.optional input.username ) ]


buildUsers_inc_input : (Users_inc_inputOptionalFields -> Users_inc_inputOptionalFields) -> Users_inc_input
buildUsers_inc_input fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Users_inc_inputOptionalFields =
    { id : OptionalArgument Int }


{-| Type for the Users\_inc\_input input object.
-}
type alias Users_inc_input =
    { id : OptionalArgument Int }


{-| Encode a Users\_inc\_input into a value that can be used as an argument.
-}
encodeUsers_inc_input : Users_inc_input -> Value
encodeUsers_inc_input input =
    Encode.maybeObject
        [ ( "id", Encode.int |> Encode.optional input.id ) ]


buildUsers_insert_input : (Users_insert_inputOptionalFields -> Users_insert_inputOptionalFields) -> Users_insert_input
buildUsers_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { created_at = Absent, id = Absent, last_seen = Absent, password = Absent, token = Absent, username = Absent }
    in
    { created_at = optionals.created_at, id = optionals.id, last_seen = optionals.last_seen, password = optionals.password, token = optionals.token, username = optionals.username }


type alias Users_insert_inputOptionalFields =
    { created_at : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , id : OptionalArgument Int
    , last_seen : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , password : OptionalArgument String
    , token : OptionalArgument String
    , username : OptionalArgument String
    }


{-| Type for the Users\_insert\_input input object.
-}
type alias Users_insert_input =
    { created_at : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , id : OptionalArgument Int
    , last_seen : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , password : OptionalArgument String
    , token : OptionalArgument String
    , username : OptionalArgument String
    }


{-| Encode a Users\_insert\_input into a value that can be used as an argument.
-}
encodeUsers_insert_input : Users_insert_input -> Value
encodeUsers_insert_input input =
    Encode.maybeObject
        [ ( "created_at", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.created_at ), ( "id", Encode.int |> Encode.optional input.id ), ( "last_seen", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.last_seen ), ( "password", Encode.string |> Encode.optional input.password ), ( "token", Encode.string |> Encode.optional input.token ), ( "username", Encode.string |> Encode.optional input.username ) ]


buildUsers_max_order_by : (Users_max_order_byOptionalFields -> Users_max_order_byOptionalFields) -> Users_max_order_by
buildUsers_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { created_at = Absent, id = Absent, last_seen = Absent, password = Absent, token = Absent, username = Absent }
    in
    { created_at = optionals.created_at, id = optionals.id, last_seen = optionals.last_seen, password = optionals.password, token = optionals.token, username = optionals.username }


type alias Users_max_order_byOptionalFields =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , last_seen : OptionalArgument Hasura.Enum.Order_by.Order_by
    , password : OptionalArgument Hasura.Enum.Order_by.Order_by
    , token : OptionalArgument Hasura.Enum.Order_by.Order_by
    , username : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Users\_max\_order\_by input object.
-}
type alias Users_max_order_by =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , last_seen : OptionalArgument Hasura.Enum.Order_by.Order_by
    , password : OptionalArgument Hasura.Enum.Order_by.Order_by
    , token : OptionalArgument Hasura.Enum.Order_by.Order_by
    , username : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Users\_max\_order\_by into a value that can be used as an argument.
-}
encodeUsers_max_order_by : Users_max_order_by -> Value
encodeUsers_max_order_by input =
    Encode.maybeObject
        [ ( "created_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.created_at ), ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ), ( "last_seen", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.last_seen ), ( "password", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.password ), ( "token", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.token ), ( "username", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.username ) ]


buildUsers_min_order_by : (Users_min_order_byOptionalFields -> Users_min_order_byOptionalFields) -> Users_min_order_by
buildUsers_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { created_at = Absent, id = Absent, last_seen = Absent, password = Absent, token = Absent, username = Absent }
    in
    { created_at = optionals.created_at, id = optionals.id, last_seen = optionals.last_seen, password = optionals.password, token = optionals.token, username = optionals.username }


type alias Users_min_order_byOptionalFields =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , last_seen : OptionalArgument Hasura.Enum.Order_by.Order_by
    , password : OptionalArgument Hasura.Enum.Order_by.Order_by
    , token : OptionalArgument Hasura.Enum.Order_by.Order_by
    , username : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Users\_min\_order\_by input object.
-}
type alias Users_min_order_by =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , last_seen : OptionalArgument Hasura.Enum.Order_by.Order_by
    , password : OptionalArgument Hasura.Enum.Order_by.Order_by
    , token : OptionalArgument Hasura.Enum.Order_by.Order_by
    , username : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Users\_min\_order\_by into a value that can be used as an argument.
-}
encodeUsers_min_order_by : Users_min_order_by -> Value
encodeUsers_min_order_by input =
    Encode.maybeObject
        [ ( "created_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.created_at ), ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ), ( "last_seen", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.last_seen ), ( "password", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.password ), ( "token", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.token ), ( "username", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.username ) ]


buildUsers_obj_rel_insert_input : Users_obj_rel_insert_inputRequiredFields -> (Users_obj_rel_insert_inputOptionalFields -> Users_obj_rel_insert_inputOptionalFields) -> Users_obj_rel_insert_input
buildUsers_obj_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    { data = required.data, on_conflict = optionals.on_conflict }


type alias Users_obj_rel_insert_inputRequiredFields =
    { data : Users_insert_input }


type alias Users_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Users_on_conflict }


{-| Type for the Users\_obj\_rel\_insert\_input input object.
-}
type alias Users_obj_rel_insert_input =
    { data : Users_insert_input
    , on_conflict : OptionalArgument Users_on_conflict
    }


{-| Encode a Users\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeUsers_obj_rel_insert_input : Users_obj_rel_insert_input -> Value
encodeUsers_obj_rel_insert_input input =
    Encode.maybeObject
        [ ( "data", encodeUsers_insert_input input.data |> Just ), ( "on_conflict", encodeUsers_on_conflict |> Encode.optional input.on_conflict ) ]


buildUsers_on_conflict : Users_on_conflictRequiredFields -> Users_on_conflict
buildUsers_on_conflict required =
    { constraint = required.constraint, update_columns = required.update_columns }


type alias Users_on_conflictRequiredFields =
    { constraint : Hasura.Enum.Users_constraint.Users_constraint
    , update_columns : List Hasura.Enum.Users_update_column.Users_update_column
    }


{-| Type for the Users\_on\_conflict input object.
-}
type alias Users_on_conflict =
    { constraint : Hasura.Enum.Users_constraint.Users_constraint
    , update_columns : List Hasura.Enum.Users_update_column.Users_update_column
    }


{-| Encode a Users\_on\_conflict into a value that can be used as an argument.
-}
encodeUsers_on_conflict : Users_on_conflict -> Value
encodeUsers_on_conflict input =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Hasura.Enum.Users_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Hasura.Enum.Users_update_column.toString |> Encode.list) input.update_columns |> Just ) ]


buildUsers_order_by : (Users_order_byOptionalFields -> Users_order_byOptionalFields) -> Users_order_by
buildUsers_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { created_at = Absent, id = Absent, last_seen = Absent, password = Absent, token = Absent, username = Absent }
    in
    { created_at = optionals.created_at, id = optionals.id, last_seen = optionals.last_seen, password = optionals.password, token = optionals.token, username = optionals.username }


type alias Users_order_byOptionalFields =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , last_seen : OptionalArgument Hasura.Enum.Order_by.Order_by
    , password : OptionalArgument Hasura.Enum.Order_by.Order_by
    , token : OptionalArgument Hasura.Enum.Order_by.Order_by
    , username : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Users\_order\_by input object.
-}
type alias Users_order_by =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , last_seen : OptionalArgument Hasura.Enum.Order_by.Order_by
    , password : OptionalArgument Hasura.Enum.Order_by.Order_by
    , token : OptionalArgument Hasura.Enum.Order_by.Order_by
    , username : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Users\_order\_by into a value that can be used as an argument.
-}
encodeUsers_order_by : Users_order_by -> Value
encodeUsers_order_by input =
    Encode.maybeObject
        [ ( "created_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.created_at ), ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ), ( "last_seen", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.last_seen ), ( "password", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.password ), ( "token", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.token ), ( "username", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.username ) ]


buildUsers_set_input : (Users_set_inputOptionalFields -> Users_set_inputOptionalFields) -> Users_set_input
buildUsers_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { created_at = Absent, id = Absent, last_seen = Absent, password = Absent, token = Absent, username = Absent }
    in
    { created_at = optionals.created_at, id = optionals.id, last_seen = optionals.last_seen, password = optionals.password, token = optionals.token, username = optionals.username }


type alias Users_set_inputOptionalFields =
    { created_at : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , id : OptionalArgument Int
    , last_seen : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , password : OptionalArgument String
    , token : OptionalArgument String
    , username : OptionalArgument String
    }


{-| Type for the Users\_set\_input input object.
-}
type alias Users_set_input =
    { created_at : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , id : OptionalArgument Int
    , last_seen : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , password : OptionalArgument String
    , token : OptionalArgument String
    , username : OptionalArgument String
    }


{-| Encode a Users\_set\_input into a value that can be used as an argument.
-}
encodeUsers_set_input : Users_set_input -> Value
encodeUsers_set_input input =
    Encode.maybeObject
        [ ( "created_at", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.created_at ), ( "id", Encode.int |> Encode.optional input.id ), ( "last_seen", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.last_seen ), ( "password", Encode.string |> Encode.optional input.password ), ( "token", Encode.string |> Encode.optional input.token ), ( "username", Encode.string |> Encode.optional input.username ) ]


buildUsers_stddev_order_by : (Users_stddev_order_byOptionalFields -> Users_stddev_order_byOptionalFields) -> Users_stddev_order_by
buildUsers_stddev_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Users_stddev_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Users\_stddev\_order\_by input object.
-}
type alias Users_stddev_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Users\_stddev\_order\_by into a value that can be used as an argument.
-}
encodeUsers_stddev_order_by : Users_stddev_order_by -> Value
encodeUsers_stddev_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildUsers_stddev_pop_order_by : (Users_stddev_pop_order_byOptionalFields -> Users_stddev_pop_order_byOptionalFields) -> Users_stddev_pop_order_by
buildUsers_stddev_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Users_stddev_pop_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Users\_stddev\_pop\_order\_by input object.
-}
type alias Users_stddev_pop_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Users\_stddev\_pop\_order\_by into a value that can be used as an argument.
-}
encodeUsers_stddev_pop_order_by : Users_stddev_pop_order_by -> Value
encodeUsers_stddev_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildUsers_stddev_samp_order_by : (Users_stddev_samp_order_byOptionalFields -> Users_stddev_samp_order_byOptionalFields) -> Users_stddev_samp_order_by
buildUsers_stddev_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Users_stddev_samp_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Users\_stddev\_samp\_order\_by input object.
-}
type alias Users_stddev_samp_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Users\_stddev\_samp\_order\_by into a value that can be used as an argument.
-}
encodeUsers_stddev_samp_order_by : Users_stddev_samp_order_by -> Value
encodeUsers_stddev_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildUsers_sum_order_by : (Users_sum_order_byOptionalFields -> Users_sum_order_byOptionalFields) -> Users_sum_order_by
buildUsers_sum_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Users_sum_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Users\_sum\_order\_by input object.
-}
type alias Users_sum_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Users\_sum\_order\_by into a value that can be used as an argument.
-}
encodeUsers_sum_order_by : Users_sum_order_by -> Value
encodeUsers_sum_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildUsers_var_pop_order_by : (Users_var_pop_order_byOptionalFields -> Users_var_pop_order_byOptionalFields) -> Users_var_pop_order_by
buildUsers_var_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Users_var_pop_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Users\_var\_pop\_order\_by input object.
-}
type alias Users_var_pop_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Users\_var\_pop\_order\_by into a value that can be used as an argument.
-}
encodeUsers_var_pop_order_by : Users_var_pop_order_by -> Value
encodeUsers_var_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildUsers_var_samp_order_by : (Users_var_samp_order_byOptionalFields -> Users_var_samp_order_byOptionalFields) -> Users_var_samp_order_by
buildUsers_var_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Users_var_samp_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Users\_var\_samp\_order\_by input object.
-}
type alias Users_var_samp_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Users\_var\_samp\_order\_by into a value that can be used as an argument.
-}
encodeUsers_var_samp_order_by : Users_var_samp_order_by -> Value
encodeUsers_var_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildUsers_variance_order_by : (Users_variance_order_byOptionalFields -> Users_variance_order_byOptionalFields) -> Users_variance_order_by
buildUsers_variance_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Users_variance_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Users\_variance\_order\_by input object.
-}
type alias Users_variance_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Users\_variance\_order\_by into a value that can be used as an argument.
-}
encodeUsers_variance_order_by : Users_variance_order_by -> Value
encodeUsers_variance_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ) ]
