-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Hasura.InputObject exposing (Author_aggregate_order_by, Author_aggregate_order_byOptionalFields, Author_arr_rel_insert_input, Author_arr_rel_insert_inputOptionalFields, Author_arr_rel_insert_inputRequiredFields, Author_avg_order_by, Author_avg_order_byOptionalFields, Author_bool_exp(..), Author_bool_expOptionalFields, Author_bool_expRaw, Author_inc_input, Author_inc_inputOptionalFields, Author_insert_input, Author_insert_inputOptionalFields, Author_max_order_by, Author_max_order_byOptionalFields, Author_min_order_by, Author_min_order_byOptionalFields, Author_obj_rel_insert_input, Author_obj_rel_insert_inputOptionalFields, Author_obj_rel_insert_inputRequiredFields, Author_on_conflict, Author_on_conflictRequiredFields, Author_order_by, Author_order_byOptionalFields, Author_set_input, Author_set_inputOptionalFields, Author_stddev_order_by, Author_stddev_order_byOptionalFields, Author_stddev_pop_order_by, Author_stddev_pop_order_byOptionalFields, Author_stddev_samp_order_by, Author_stddev_samp_order_byOptionalFields, Author_sum_order_by, Author_sum_order_byOptionalFields, Author_var_pop_order_by, Author_var_pop_order_byOptionalFields, Author_var_samp_order_by, Author_var_samp_order_byOptionalFields, Author_variance_order_by, Author_variance_order_byOptionalFields, Integer_comparison_exp, Integer_comparison_expOptionalFields, Text_comparison_exp, Text_comparison_expOptionalFields, buildAuthor_aggregate_order_by, buildAuthor_arr_rel_insert_input, buildAuthor_avg_order_by, buildAuthor_bool_exp, buildAuthor_inc_input, buildAuthor_insert_input, buildAuthor_max_order_by, buildAuthor_min_order_by, buildAuthor_obj_rel_insert_input, buildAuthor_on_conflict, buildAuthor_order_by, buildAuthor_set_input, buildAuthor_stddev_order_by, buildAuthor_stddev_pop_order_by, buildAuthor_stddev_samp_order_by, buildAuthor_sum_order_by, buildAuthor_var_pop_order_by, buildAuthor_var_samp_order_by, buildAuthor_variance_order_by, buildInteger_comparison_exp, buildText_comparison_exp, encodeAuthor_aggregate_order_by, encodeAuthor_arr_rel_insert_input, encodeAuthor_avg_order_by, encodeAuthor_bool_exp, encodeAuthor_inc_input, encodeAuthor_insert_input, encodeAuthor_max_order_by, encodeAuthor_min_order_by, encodeAuthor_obj_rel_insert_input, encodeAuthor_on_conflict, encodeAuthor_order_by, encodeAuthor_set_input, encodeAuthor_stddev_order_by, encodeAuthor_stddev_pop_order_by, encodeAuthor_stddev_samp_order_by, encodeAuthor_sum_order_by, encodeAuthor_var_pop_order_by, encodeAuthor_var_samp_order_by, encodeAuthor_variance_order_by, encodeInteger_comparison_exp, encodeText_comparison_exp)

import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Hasura.Enum.Author_constraint
import Hasura.Enum.Author_update_column
import Hasura.Enum.Order_by
import Hasura.Interface
import Hasura.Object
import Hasura.Scalar
import Hasura.ScalarCodecs
import Hasura.Union
import Json.Decode as Decode


buildAuthor_aggregate_order_by : (Author_aggregate_order_byOptionalFields -> Author_aggregate_order_byOptionalFields) -> Author_aggregate_order_by
buildAuthor_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { avg = Absent, count = Absent, max = Absent, min = Absent, stddev = Absent, stddev_pop = Absent, stddev_samp = Absent, sum = Absent, var_pop = Absent, var_samp = Absent, variance = Absent }
    in
    { avg = optionals.avg, count = optionals.count, max = optionals.max, min = optionals.min, stddev = optionals.stddev, stddev_pop = optionals.stddev_pop, stddev_samp = optionals.stddev_samp, sum = optionals.sum, var_pop = optionals.var_pop, var_samp = optionals.var_samp, variance = optionals.variance }


type alias Author_aggregate_order_byOptionalFields =
    { avg : OptionalArgument Author_avg_order_by
    , count : OptionalArgument Hasura.Enum.Order_by.Order_by
    , max : OptionalArgument Author_max_order_by
    , min : OptionalArgument Author_min_order_by
    , stddev : OptionalArgument Author_stddev_order_by
    , stddev_pop : OptionalArgument Author_stddev_pop_order_by
    , stddev_samp : OptionalArgument Author_stddev_samp_order_by
    , sum : OptionalArgument Author_sum_order_by
    , var_pop : OptionalArgument Author_var_pop_order_by
    , var_samp : OptionalArgument Author_var_samp_order_by
    , variance : OptionalArgument Author_variance_order_by
    }


{-| Type for the Author\_aggregate\_order\_by input object.
-}
type alias Author_aggregate_order_by =
    { avg : OptionalArgument Author_avg_order_by
    , count : OptionalArgument Hasura.Enum.Order_by.Order_by
    , max : OptionalArgument Author_max_order_by
    , min : OptionalArgument Author_min_order_by
    , stddev : OptionalArgument Author_stddev_order_by
    , stddev_pop : OptionalArgument Author_stddev_pop_order_by
    , stddev_samp : OptionalArgument Author_stddev_samp_order_by
    , sum : OptionalArgument Author_sum_order_by
    , var_pop : OptionalArgument Author_var_pop_order_by
    , var_samp : OptionalArgument Author_var_samp_order_by
    , variance : OptionalArgument Author_variance_order_by
    }


{-| Encode a Author\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeAuthor_aggregate_order_by : Author_aggregate_order_by -> Value
encodeAuthor_aggregate_order_by input =
    Encode.maybeObject
        [ ( "avg", encodeAuthor_avg_order_by |> Encode.optional input.avg ), ( "count", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeAuthor_max_order_by |> Encode.optional input.max ), ( "min", encodeAuthor_min_order_by |> Encode.optional input.min ), ( "stddev", encodeAuthor_stddev_order_by |> Encode.optional input.stddev ), ( "stddev_pop", encodeAuthor_stddev_pop_order_by |> Encode.optional input.stddev_pop ), ( "stddev_samp", encodeAuthor_stddev_samp_order_by |> Encode.optional input.stddev_samp ), ( "sum", encodeAuthor_sum_order_by |> Encode.optional input.sum ), ( "var_pop", encodeAuthor_var_pop_order_by |> Encode.optional input.var_pop ), ( "var_samp", encodeAuthor_var_samp_order_by |> Encode.optional input.var_samp ), ( "variance", encodeAuthor_variance_order_by |> Encode.optional input.variance ) ]


buildAuthor_arr_rel_insert_input : Author_arr_rel_insert_inputRequiredFields -> (Author_arr_rel_insert_inputOptionalFields -> Author_arr_rel_insert_inputOptionalFields) -> Author_arr_rel_insert_input
buildAuthor_arr_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    { data = required.data, on_conflict = optionals.on_conflict }


type alias Author_arr_rel_insert_inputRequiredFields =
    { data : List Author_insert_input }


type alias Author_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Author_on_conflict }


{-| Type for the Author\_arr\_rel\_insert\_input input object.
-}
type alias Author_arr_rel_insert_input =
    { data : List Author_insert_input
    , on_conflict : OptionalArgument Author_on_conflict
    }


{-| Encode a Author\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeAuthor_arr_rel_insert_input : Author_arr_rel_insert_input -> Value
encodeAuthor_arr_rel_insert_input input =
    Encode.maybeObject
        [ ( "data", (encodeAuthor_insert_input |> Encode.list) input.data |> Just ), ( "on_conflict", encodeAuthor_on_conflict |> Encode.optional input.on_conflict ) ]


buildAuthor_avg_order_by : (Author_avg_order_byOptionalFields -> Author_avg_order_byOptionalFields) -> Author_avg_order_by
buildAuthor_avg_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Author_avg_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Author\_avg\_order\_by input object.
-}
type alias Author_avg_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Author\_avg\_order\_by into a value that can be used as an argument.
-}
encodeAuthor_avg_order_by : Author_avg_order_by -> Value
encodeAuthor_avg_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildAuthor_bool_exp : (Author_bool_expOptionalFields -> Author_bool_expOptionalFields) -> Author_bool_exp
buildAuthor_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, id = Absent, name = Absent }
    in
    Author_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, id = optionals.id, name = optionals.name }


type alias Author_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Author_bool_exp))
    , not_ : OptionalArgument Author_bool_exp
    , or_ : OptionalArgument (List (Maybe Author_bool_exp))
    , id : OptionalArgument Integer_comparison_exp
    , name : OptionalArgument Text_comparison_exp
    }


{-| Type alias for the `Author_bool_exp` attributes. Note that this type
needs to use the `Author_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Author_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Author_bool_exp))
    , not_ : OptionalArgument Author_bool_exp
    , or_ : OptionalArgument (List (Maybe Author_bool_exp))
    , id : OptionalArgument Integer_comparison_exp
    , name : OptionalArgument Text_comparison_exp
    }


{-| Type for the Author\_bool\_exp input object.
-}
type Author_bool_exp
    = Author_bool_exp Author_bool_expRaw


{-| Encode a Author\_bool\_exp into a value that can be used as an argument.
-}
encodeAuthor_bool_exp : Author_bool_exp -> Value
encodeAuthor_bool_exp (Author_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeAuthor_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeAuthor_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeAuthor_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "id", encodeInteger_comparison_exp |> Encode.optional input.id ), ( "name", encodeText_comparison_exp |> Encode.optional input.name ) ]


buildAuthor_inc_input : (Author_inc_inputOptionalFields -> Author_inc_inputOptionalFields) -> Author_inc_input
buildAuthor_inc_input fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Author_inc_inputOptionalFields =
    { id : OptionalArgument Int }


{-| Type for the Author\_inc\_input input object.
-}
type alias Author_inc_input =
    { id : OptionalArgument Int }


{-| Encode a Author\_inc\_input into a value that can be used as an argument.
-}
encodeAuthor_inc_input : Author_inc_input -> Value
encodeAuthor_inc_input input =
    Encode.maybeObject
        [ ( "id", Encode.int |> Encode.optional input.id ) ]


buildAuthor_insert_input : (Author_insert_inputOptionalFields -> Author_insert_inputOptionalFields) -> Author_insert_input
buildAuthor_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, name = Absent }
    in
    { id = optionals.id, name = optionals.name }


type alias Author_insert_inputOptionalFields =
    { id : OptionalArgument Int
    , name : OptionalArgument String
    }


{-| Type for the Author\_insert\_input input object.
-}
type alias Author_insert_input =
    { id : OptionalArgument Int
    , name : OptionalArgument String
    }


{-| Encode a Author\_insert\_input into a value that can be used as an argument.
-}
encodeAuthor_insert_input : Author_insert_input -> Value
encodeAuthor_insert_input input =
    Encode.maybeObject
        [ ( "id", Encode.int |> Encode.optional input.id ), ( "name", Encode.string |> Encode.optional input.name ) ]


buildAuthor_max_order_by : (Author_max_order_byOptionalFields -> Author_max_order_byOptionalFields) -> Author_max_order_by
buildAuthor_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, name = Absent }
    in
    { id = optionals.id, name = optionals.name }


type alias Author_max_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , name : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Author\_max\_order\_by input object.
-}
type alias Author_max_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , name : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Author\_max\_order\_by into a value that can be used as an argument.
-}
encodeAuthor_max_order_by : Author_max_order_by -> Value
encodeAuthor_max_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ), ( "name", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.name ) ]


buildAuthor_min_order_by : (Author_min_order_byOptionalFields -> Author_min_order_byOptionalFields) -> Author_min_order_by
buildAuthor_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, name = Absent }
    in
    { id = optionals.id, name = optionals.name }


type alias Author_min_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , name : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Author\_min\_order\_by input object.
-}
type alias Author_min_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , name : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Author\_min\_order\_by into a value that can be used as an argument.
-}
encodeAuthor_min_order_by : Author_min_order_by -> Value
encodeAuthor_min_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ), ( "name", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.name ) ]


buildAuthor_obj_rel_insert_input : Author_obj_rel_insert_inputRequiredFields -> (Author_obj_rel_insert_inputOptionalFields -> Author_obj_rel_insert_inputOptionalFields) -> Author_obj_rel_insert_input
buildAuthor_obj_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    { data = required.data, on_conflict = optionals.on_conflict }


type alias Author_obj_rel_insert_inputRequiredFields =
    { data : Author_insert_input }


type alias Author_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Author_on_conflict }


{-| Type for the Author\_obj\_rel\_insert\_input input object.
-}
type alias Author_obj_rel_insert_input =
    { data : Author_insert_input
    , on_conflict : OptionalArgument Author_on_conflict
    }


{-| Encode a Author\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeAuthor_obj_rel_insert_input : Author_obj_rel_insert_input -> Value
encodeAuthor_obj_rel_insert_input input =
    Encode.maybeObject
        [ ( "data", encodeAuthor_insert_input input.data |> Just ), ( "on_conflict", encodeAuthor_on_conflict |> Encode.optional input.on_conflict ) ]


buildAuthor_on_conflict : Author_on_conflictRequiredFields -> Author_on_conflict
buildAuthor_on_conflict required =
    { constraint = required.constraint, update_columns = required.update_columns }


type alias Author_on_conflictRequiredFields =
    { constraint : Hasura.Enum.Author_constraint.Author_constraint
    , update_columns : List Hasura.Enum.Author_update_column.Author_update_column
    }


{-| Type for the Author\_on\_conflict input object.
-}
type alias Author_on_conflict =
    { constraint : Hasura.Enum.Author_constraint.Author_constraint
    , update_columns : List Hasura.Enum.Author_update_column.Author_update_column
    }


{-| Encode a Author\_on\_conflict into a value that can be used as an argument.
-}
encodeAuthor_on_conflict : Author_on_conflict -> Value
encodeAuthor_on_conflict input =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Hasura.Enum.Author_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Hasura.Enum.Author_update_column.toString |> Encode.list) input.update_columns |> Just ) ]


buildAuthor_order_by : (Author_order_byOptionalFields -> Author_order_byOptionalFields) -> Author_order_by
buildAuthor_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, name = Absent }
    in
    { id = optionals.id, name = optionals.name }


type alias Author_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , name : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Author\_order\_by input object.
-}
type alias Author_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , name : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Author\_order\_by into a value that can be used as an argument.
-}
encodeAuthor_order_by : Author_order_by -> Value
encodeAuthor_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ), ( "name", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.name ) ]


buildAuthor_set_input : (Author_set_inputOptionalFields -> Author_set_inputOptionalFields) -> Author_set_input
buildAuthor_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, name = Absent }
    in
    { id = optionals.id, name = optionals.name }


type alias Author_set_inputOptionalFields =
    { id : OptionalArgument Int
    , name : OptionalArgument String
    }


{-| Type for the Author\_set\_input input object.
-}
type alias Author_set_input =
    { id : OptionalArgument Int
    , name : OptionalArgument String
    }


{-| Encode a Author\_set\_input into a value that can be used as an argument.
-}
encodeAuthor_set_input : Author_set_input -> Value
encodeAuthor_set_input input =
    Encode.maybeObject
        [ ( "id", Encode.int |> Encode.optional input.id ), ( "name", Encode.string |> Encode.optional input.name ) ]


buildAuthor_stddev_order_by : (Author_stddev_order_byOptionalFields -> Author_stddev_order_byOptionalFields) -> Author_stddev_order_by
buildAuthor_stddev_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Author_stddev_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Author\_stddev\_order\_by input object.
-}
type alias Author_stddev_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Author\_stddev\_order\_by into a value that can be used as an argument.
-}
encodeAuthor_stddev_order_by : Author_stddev_order_by -> Value
encodeAuthor_stddev_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildAuthor_stddev_pop_order_by : (Author_stddev_pop_order_byOptionalFields -> Author_stddev_pop_order_byOptionalFields) -> Author_stddev_pop_order_by
buildAuthor_stddev_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Author_stddev_pop_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Author\_stddev\_pop\_order\_by input object.
-}
type alias Author_stddev_pop_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Author\_stddev\_pop\_order\_by into a value that can be used as an argument.
-}
encodeAuthor_stddev_pop_order_by : Author_stddev_pop_order_by -> Value
encodeAuthor_stddev_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildAuthor_stddev_samp_order_by : (Author_stddev_samp_order_byOptionalFields -> Author_stddev_samp_order_byOptionalFields) -> Author_stddev_samp_order_by
buildAuthor_stddev_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Author_stddev_samp_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Author\_stddev\_samp\_order\_by input object.
-}
type alias Author_stddev_samp_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Author\_stddev\_samp\_order\_by into a value that can be used as an argument.
-}
encodeAuthor_stddev_samp_order_by : Author_stddev_samp_order_by -> Value
encodeAuthor_stddev_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildAuthor_sum_order_by : (Author_sum_order_byOptionalFields -> Author_sum_order_byOptionalFields) -> Author_sum_order_by
buildAuthor_sum_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Author_sum_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Author\_sum\_order\_by input object.
-}
type alias Author_sum_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Author\_sum\_order\_by into a value that can be used as an argument.
-}
encodeAuthor_sum_order_by : Author_sum_order_by -> Value
encodeAuthor_sum_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildAuthor_var_pop_order_by : (Author_var_pop_order_byOptionalFields -> Author_var_pop_order_byOptionalFields) -> Author_var_pop_order_by
buildAuthor_var_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Author_var_pop_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Author\_var\_pop\_order\_by input object.
-}
type alias Author_var_pop_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Author\_var\_pop\_order\_by into a value that can be used as an argument.
-}
encodeAuthor_var_pop_order_by : Author_var_pop_order_by -> Value
encodeAuthor_var_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildAuthor_var_samp_order_by : (Author_var_samp_order_byOptionalFields -> Author_var_samp_order_byOptionalFields) -> Author_var_samp_order_by
buildAuthor_var_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Author_var_samp_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Author\_var\_samp\_order\_by input object.
-}
type alias Author_var_samp_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Author\_var\_samp\_order\_by into a value that can be used as an argument.
-}
encodeAuthor_var_samp_order_by : Author_var_samp_order_by -> Value
encodeAuthor_var_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildAuthor_variance_order_by : (Author_variance_order_byOptionalFields -> Author_variance_order_byOptionalFields) -> Author_variance_order_by
buildAuthor_variance_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Author_variance_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Author\_variance\_order\_by input object.
-}
type alias Author_variance_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Author\_variance\_order\_by into a value that can be used as an argument.
-}
encodeAuthor_variance_order_by : Author_variance_order_by -> Value
encodeAuthor_variance_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildInteger_comparison_exp : (Integer_comparison_expOptionalFields -> Integer_comparison_expOptionalFields) -> Integer_comparison_exp
buildInteger_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Integer_comparison_expOptionalFields =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List (Maybe Int))
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List (Maybe Int))
    }


{-| Type for the Integer\_comparison\_exp input object.
-}
type alias Integer_comparison_exp =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List (Maybe Int))
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List (Maybe Int))
    }


{-| Encode a Integer\_comparison\_exp into a value that can be used as an argument.
-}
encodeInteger_comparison_exp : Integer_comparison_exp -> Value
encodeInteger_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.int |> Encode.optional input.eq_ ), ( "_gt", Encode.int |> Encode.optional input.gt_ ), ( "_gte", Encode.int |> Encode.optional input.gte_ ), ( "_in", (Encode.int |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", Encode.int |> Encode.optional input.lt_ ), ( "_lte", Encode.int |> Encode.optional input.lte_ ), ( "_neq", Encode.int |> Encode.optional input.neq_ ), ( "_nin", (Encode.int |> Encode.maybe |> Encode.list) |> Encode.optional input.nin_ ) ]


buildText_comparison_exp : (Text_comparison_expOptionalFields -> Text_comparison_expOptionalFields) -> Text_comparison_exp
buildText_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, ilike_ = Absent, in_ = Absent, is_null_ = Absent, like_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nilike_ = Absent, nin_ = Absent, nlike_ = Absent, nsimilar_ = Absent, similar_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, ilike_ = optionals.ilike_, in_ = optionals.in_, is_null_ = optionals.is_null_, like_ = optionals.like_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nilike_ = optionals.nilike_, nin_ = optionals.nin_, nlike_ = optionals.nlike_, nsimilar_ = optionals.nsimilar_, similar_ = optionals.similar_ }


type alias Text_comparison_expOptionalFields =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List (Maybe String))
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Type for the Text\_comparison\_exp input object.
-}
type alias Text_comparison_exp =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List (Maybe String))
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Encode a Text\_comparison\_exp into a value that can be used as an argument.
-}
encodeText_comparison_exp : Text_comparison_exp -> Value
encodeText_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.string |> Encode.optional input.eq_ ), ( "_gt", Encode.string |> Encode.optional input.gt_ ), ( "_gte", Encode.string |> Encode.optional input.gte_ ), ( "_ilike", Encode.string |> Encode.optional input.ilike_ ), ( "_in", (Encode.string |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_like", Encode.string |> Encode.optional input.like_ ), ( "_lt", Encode.string |> Encode.optional input.lt_ ), ( "_lte", Encode.string |> Encode.optional input.lte_ ), ( "_neq", Encode.string |> Encode.optional input.neq_ ), ( "_nilike", Encode.string |> Encode.optional input.nilike_ ), ( "_nin", (Encode.string |> Encode.maybe |> Encode.list) |> Encode.optional input.nin_ ), ( "_nlike", Encode.string |> Encode.optional input.nlike_ ), ( "_nsimilar", Encode.string |> Encode.optional input.nsimilar_ ), ( "_similar", Encode.string |> Encode.optional input.similar_ ) ]
